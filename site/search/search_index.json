{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programmieren II","text":"<p>Herzlich willkommen zur Programmieren II-Veranstaltung! Sie haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis moderner Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und werden eine REST-API bauen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben:</p> <ol> <li>L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben!</li> <li>Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen!</li> <li>Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist.</li> <li>Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren...</li> <li>Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens.</li> <li>Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das ganze Semester \u00fcber Spa\u00df am Programmieren haben werden. </li> </ol> <p>Viel Erfolg! Und viel Spa\u00df!</p>"},{"location":"#organisatorisches","title":"Organisatorisches","text":"<p>Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt:</p> <ul> <li>Einige der Themen werden ausf\u00fchrlich in diesem Skript beschrieben und in den Vorlesungen eingef\u00fchrt und verdeutlicht.</li> <li>F\u00fcr die anderen Themen werden sie Skripte k\u00fcrzer ausfallen und daf\u00fcr mich Links vervollst\u00e4ndigt.  </li> <li>Die Veranstaltungen finden in Pr\u00e4senz statt. Es werden keine Videos erstellt.</li> <li>Das Skript wird f\u00fcr die jeweilige Woche montags hochgeladen.</li> <li>Mit dem Skript wird sowohl die \u00dcbung f\u00fcr die Woche als auch die neue Aufgabe hochgeladen.</li> <li>Die \u00dcbung (und die vergangene Aufgabe) werden dienstags (09:45 - 11:15 bzw. 12:15 - 13:45 Uhr) besprochen. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen.</li> <li>Die Veranstaltung wird durch ein Tutorium unterst\u00fctzt. Der Termin f\u00fcr das Tutorium wird noch bekanntgegeben.</li> <li>Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu</li> </ul> <p>Zur erfolgreichen Durchf\u00fchrung der Veranstaltung sollten Sie die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Sollte Ihre L\u00f6sung der L\u00f6sung entsprechen, die im Tutorium erarbeitet wurde, brauchen Sie diese L\u00f6sung nicht hochzuladen. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Bitte beachten Sie, dass das Modul erfahrungsgem\u00e4\u00df nur dann bestanden werden kann, wenn Sie die \u00dcbungen und Aufgaben selbstst\u00e4ndig l\u00f6sen k\u00f6nnen. Selbst wenn Ihnen zun\u00e4chst eine eigene L\u00f6sung schwerf\u00e4llt, m\u00fcssen Sie es irgendwann im Laufe des Semsters - am besten, jeweils so schnell wie m\u00f6glich - schaffen, diese Aufgaben selbstst\u00e4ndig zu implementieren.</p> <p>Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt.</p> <p>Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen, die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen.</p> <p>F\u00fcr die Kommunikation untereinander verwenden wir Slack. Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!</p>"},{"location":"#grober-inhalt-kann-sich-noch-andern","title":"Grober Inhalt (kann sich noch \u00e4ndern)","text":"<p>Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln.</p> <p>Nachfolgend der vorl\u00e4ufige Wochenplan (wird angepasst).</p> Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 9.04.2024 Organisatorisches, Wiederholung, Aufz\u00e4hlungstypen - \u00a0- - 1. 16.04.2024 Wrapper-Klassen (boxing und unboxing)Exceptions I \u00dcbung 1 Aufgabe 1 26.4.2024 2. 23.04.2024 Exceptions II - - 3. 30.04.2024 Collections (List und Set) - - - 4. 7.05.2024 Collections (Map) und Abstrakte Klassen - - - 5. 14.05.2024 Interfaces - - - 6. 21.05.2024 - - - - 7. 28.05.2024 - - - - 8. 4.06.2024 - - - - 9. 11.06.2024 - - - - 10. 18.06.2024 - - - - 12. 25.06.2024 - - - - 13. 03.07.2024 - - - - 14. 10.07.2024 - - - - 15. 17.07.2024 - - - - wird noch bekannt gegeben Klausur 1.PZ Labore 6. Etage C-Geb\u00e4ude - - wird noch bekannt gegeben Klausur 2.PZ Labore 6. Etage C-Geb\u00e4ude - - <p>Die weitere Themen werden voraussichtlich sein: - git - Unit Tests - Streams &amp; Lamdas  - REST-API mit Micronaut - Lesbarkeit &amp; besserer Code  - TDD - Refactoring </p>"},{"location":"#inhalte","title":"Inhalte","text":""},{"location":"abstrakt/","title":"Abstrakte Klassen","text":"<p>Abstrakte Klassen  haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von <code>Collection</code> anschauen, dann finden wir darin</p> <ul> <li>Interfaces: die Klassen <code>Collection</code>, <code>List</code>, <code>Set</code>, <code>SortedSet</code> und <code>NavigableSet</code> sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und</li> <li>Abtrakte Klassen: die Klassen <code>AbstractCollection</code>, <code>AbstractList</code> und <code>AbstractSet</code> sind solche abstrakten Klassen (die schauen wir uns jetzt an)</li> </ul> <p></p>"},{"location":"abstrakt/#klassen-allgemein","title":"Klassen - allgemein","text":"<p>Wir haben uns bis jetzt Klassen erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um</li> <li>daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt.  </li> </ol> <p>Angenommen, in der Klasse wurde eine Methode implementiert</p> <pre><code>public void eineImplementierteMethode()\n{\n    // Anweisungen\n}\n</code></pre> <p>, dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren <code>refVariable.eineImplementierteMethode();</code>. </p>"},{"location":"abstrakt/#klassen-abstrakt","title":"Klassen - abstrakt","text":"<p>Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen. Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um </p> <ol> <li>sie als einen neuen (Referenz-)Typ zu verwenden, um</li> <li>von diesen Klassen alle Eigenschaften erben zu lassen. </li> </ol> <p>Der dritte obere Punkt gilt nicht! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen. </p> <p>Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse.</p>"},{"location":"abstrakt/#abstrakte-methoden","title":"Abstrakte Methoden","text":"<p>Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon):</p> <pre><code>public abstract void eineAbstrakteMethode();\n</code></pre> <p>Das Schl\u00fcsselwort <code>abstract</code> gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, </p> <ul> <li>wie der Name der Methode lautet,</li> <li>welche Parameter die Methode erwartet,</li> <li>wie der R\u00fcckgabetyp der Methode ist und</li> <li>wie der Sichtbarkeitsmodifizierer dieser Methode ist.</li> </ul> <p>Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort <code>abstract</code> im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf haben, also keine <code>{ }</code>. Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon!</p>"},{"location":"abstrakt/#verwendung-abstrakter-klassen","title":"Verwendung abstrakter Klassen","text":"<p>Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen </p> <ol> <li>als Typ und </li> <li>als Basisklasse, d.h. von abstrakten Klassen wird geerbt.</li> </ol> <p>Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)!</p>"},{"location":"abstrakt/#ein-beispiel-die-abstrakte-klasse-shape","title":"Ein Beispiel - die abstrakte Klasse <code>Shape</code>","text":"<p>Wir erstellen uns eine abstrakte Klasse <code>Shape</code>, welche zwei abstrakte Methoden enth\u00e4lt, <code>perimeter()</code> und <code>area()</code>. </p> <pre><code>public abstract class Shape \n{   \n    public abstract double perimeter();\n    public abstract double area();\n\n}\n</code></pre> <p>Beachten Sie, dass eine Klasse selbst als <code>abstract</code> deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile <code>1</code> ebanfalls das Schl\u00fcsselwort <code>abstract</code>. Sie lie\u00dfe sich auch sonst gar nicht compilieren. </p>"},{"location":"abstrakt/#rectangle-erbt-von-shape","title":"<code>Rectangle</code> erbt von <code>Shape</code>","text":"<p><code>Shape</code> kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse <code>Shape</code> erzeugen. Vielmehr ist die Klasse <code>Shape</code> auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse <code>Rectangle</code>, die von <code>Shape</code> erbt. </p> <p>Wenn wir nun schreiben:</p> <pre><code>public class Rectangle extends Shape\n{\n\n}\n</code></pre> <p>dann ist <code>Rectangle</code> rot unterstrichen und Eclipse bietet uns zwei <code>QuickFixes</code> an:</p> <ol> <li><code>Add unimplemnted methods</code> oder</li> <li><code>Make type Rectangle abstract</code></li> </ol> <p>Durch das Erben von <code>Shape</code> haben wir auch die beiden abstrakten Methoden <code>perimeter()</code> und <code>area()</code> geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse <code>Rectangle</code> ist selbst eine abstrakte Klasse. Wir w\u00e4hlen <code>QuickFix 1</code> und lassen die Methoden hinzuf\u00fcgen: </p> <pre><code>public class Rectangle extends Shape\n{\n\n    @Override\n    public double perimeter() \n    {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public double area() \n    {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n}\n</code></pre> <p>Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als <code>public</code> und mit R\u00fcckgabetyp <code>double</code> sowie den in <code>Shape</code> definierten Namen). Nun sind die beiden Methoden aber jeweils implementiert (aber noch nicht richtig - <code>TODO</code>). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen <code>6-9</code> und <code>13-16</code>), sind sie nicht mehr abstrakt und somit ist auch die Klasse <code>Rectangle</code> keine abstrakte Klasse. </p> <p>Eine sinnvolle Implementierung der Klasse <code>Rectangle</code> sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden <code>perimeter()</code> und <code>area()</code> sinnvoll implementieren: </p> <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n}\n</code></pre> <p>Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch geeignete Implementierungen f\u00fcr mindestens die von <code>Object</code> geerbten Methoden <code>equals()</code> und <code>toString()</code> enthalten. </p>"},{"location":"abstrakt/#circle-erbt-von-shape","title":"<code>Circle</code> erbt von <code>Shape</code>","text":"<p>Wir k\u00f6nnen beliebig oft von der Klasse <code>Shape</code> erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse <code>Shape</code> erben. F\u00fcr jede dieser Klassen gilt nun:</p> <ul> <li>ein Objekt dieser Klasse (z.B. ein Objekt der Klasse <code>Rectangle</code>) \"besitzt\" die Methoden <code>perimeter()</code> und <code>area()</code>,</li> <li>ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ <code>Shape</code>. </li> </ul> <p>Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: </p> <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n}\n</code></pre>"},{"location":"abstrakt/#testen-der-klassen","title":"Testen der Klassen","text":"<p>Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein <code>Shape</code> als Parameter verwendet wird und die f\u00fcr dieses <code>Shape</code> die Methode <code>perimeter()</code> oder <code>area()</code> aufruft. Es ist ja sicher, dass jedes Objekt vom Typ <code>Shape</code> diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende <code>TestklasseShape</code>:</p> <pre><code>public class TestklasseShape \n{\n\n    public static void printPerimeter(Shape s)\n    {\n        System.out.printf(\"perimeter : %.2f cm%n\", s.perimeter());\n    }\n\n    public static void printArea(Shape s)\n    {\n        System.out.printf(\"area      : %.2f cm%n\", s.area());\n    }\n\n    public static double sumPerimeters(Shape[] shapes)\n    {\n        double sum = 0.0;\n        for(Shape s : shapes)\n        {\n            sum += s.perimeter();\n        }\n        return sum;\n    }\n\n    public static double sumAreas(Shape[] shapes)\n    {\n        double sum = 0.0;\n        for(Shape s : shapes)\n        {\n            sum += s.area();\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Shape s1 = new Rectangle(10, 20);\n        Shape s2 = new Circle(6.0);\n        printPerimeter(s1);\n        printPerimeter(s2);\n        printArea(s1);\n        printArea(s2);\n\n        Shape[] shapes = new Shape[4];\n        shapes[0] = s1;\n        shapes[1] = s2;\n        shapes[2] = new Rectangle(5,15);\n        shapes[3] = new Circle(10.0);\n        System.out.printf(\"sum of perimeters : %.2f cm%n\", sumPerimeters(shapes));\n        System.out.printf(\"sum of areas      : %.2f cm%n\", sumAreas(shapes));\n    }\n}\n</code></pre> <p>In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ <code>Shape</code> oder vom Typ <code>Shape[]</code> erwarten. Von Objekten, die vom (Laufzeit-)Typ <code>Shape</code> sind, wissen wir, dass sie die Methoden <code>perimeter()</code> bzw. <code>area()</code> als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die <code>Shape</code>-Objekte aufrufen. </p> <p>Abstrakte Klassen fungieren also ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. <code>Rectangle</code> oder <code>Circle</code>), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden <code>perimeter()</code> und <code>area()</code> verf\u00fcgen. </p>"},{"location":"abstrakt/#beispiele-aus-den-java-paketen","title":"Beispiele aus den Java-Paketen","text":"<p>In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben. </p>"},{"location":"abstrakt/#die-abstrakte-klasse-number","title":"Die abstrakte Klasse <code>Number</code>","text":"<p>Die Klasse Number aus dem <code>java.lang</code>-Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: </p> <ul> <li><code>abstract double doubleValue()</code></li> <li><code>abstract float  floatValue()</code></li> <li><code>abstract int    intValue()</code></li> <li><code>abstract long   longValue()</code></li> </ul> <p>Alle numerischen Wrapper-Klassen erben von <code>Number</code>, d.h. die Klassen <code>Byte</code>, <code>Double</code>, <code>Float</code>, <code>Integer</code>, <code>Long</code> und <code>Short</code> sind von <code>Number</code> abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ <code>Number</code> sind und somit die Methoden <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code> und <code>longValue()</code> als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen. </p>"},{"location":"abstrakt/#abstrakte-klassen-fur-collections","title":"Abstrakte Klassen f\u00fcr Collections","text":"<p>Beispiele f\u00fcr abstrakte Klassen finden wir auch im <code>java.util</code>-Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. <code>add()</code>, <code>addAll()</code>, <code>clear()</code>, <code>contains()</code>, <code>isEmpty()</code>, <code>iterator()</code>, <code>remove()</code> usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen <code>AbstractList</code> und <code>AbstractSet</code> ebenfalls abstrakt sind! Von <code>AbstractSet</code> erben z.B. die Klassen <code>HashSet</code>, <code>TreeSet</code> und <code>EnumSet</code>. Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in <code>AbstractCollection</code> definierten Methoden. </p> <p>Success</p> <p>Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.</p>"},{"location":"aufgaben/","title":"Aufgaben","text":""},{"location":"aufgaben/#aufgabe-1-wurfelspiel","title":"Aufgabe 1 (W\u00fcrfelspiel)","text":"Aufgabe 1 <p>Informieren Sie sich \u00fcber die Scanner class in java.util (Beispiele finden sie hier: https://www.programiz.com/java-programming/scanner https://javabeginners.de/Ein-_und_Ausgabe/Scanner.php https://www.w3schools.com/java/java_user_input.asp )</p> <p>Aufgabe</p> <ol> <li>Implementieren Sie folgendes W\u00fcrfelspiel:<ul> <li>An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen.</li> <li>Die Spieler sind nacheinander an der Reihe.</li> <li>Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch.</li> <li>In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder<ul> <li>eine 6 w\u00fcrfelt oder er</li> <li>den Versuch freiwillig beendet.  </li> </ul> </li> <li>Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit <code>0</code> Punkten bewertet.</li> <li>Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert).</li> </ul> </li> <li>Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. <code>20</code>) erreicht hat, hat gewonnen.      Beispiel mit zwei Spielern <code>A</code> und <code>B</code> bis Gesamtpunktzahl <code>20</code>:     </li> <li>Laden Sie Ihr L\u00f6sung in Moodle hoch! Viel Spa\u00df und viel Erfolg!</li> </ol>"},{"location":"collections/","title":"Collections","text":"<p>Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections. </p> <p>Collections haben drei wesentliche Eigenschaften:</p> <ul> <li>Eine Collection hat keine festgelegte L\u00e4nge, d.h. es sind beliebig viele Elemente in einer Collection speicherbar.</li> <li>In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen (<code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper-Klassen kennenlernen. </li> <li>Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren, damit sie nur Elemente eines Typs speichern kann.</li> </ul>"},{"location":"collections/#arten-von-collections","title":"Arten von Collections","text":"<p>Es gibt unterschiedliche Arten von Collections, welche je nach Einsatzzweck verwendet werden:</p>  Typ  \u00a0Struktur  \u00a0Zugriff   Eigenschaften  <code>List</code>  Menge   wahlfrei (indexbasiert)  Iterator  kann Elemente mehrfach enthalten  <code>Set</code>  Menge   Iterator   keine doppelten Elemente  keine Ordnung der Elemente  <code>Map</code>  Schl\u00fcssel-Werte-Paare   schl\u00fcsselbasiert  Schl\u00fcssel ist eindeutig  Werte k\u00f6nnen mehrfach sein  <code>Stack</code>  Stapel/Stack   oberstes Element  last-in-first-out-Prinzip  <code>Queue</code>  Warteschlange   erstes und letztes Element   first-in-first-out-Prinzip  <p>Wir werden uns in diesem Semester aber nur mit den Collections <code>List</code>, <code>Set</code> und <code>Map</code> besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann (<code>pop</code>) und von dem man das oberste Element entfernen kann (<code>pop</code>). Mithilfe von <code>top</code> erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. </p> <p>Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head) der Warteschlange. </p> <p>Eine Liste (<code>List</code>) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente <code>e1</code> und <code>e2</code> gilt <code>e1.equals(e2) == true</code> (oder <code>e1.hashCode() == e2.hashCode()</code>). </p> <p>Eine Menge (<code>Set</code>) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die <code>add(element)</code>-Methode f\u00fcr eine Menge ein <code>boolean</code> zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde (<code>true</code>) oder nicht (<code>false</code>). </p> <p>Eine <code>Map</code> kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel <code>key</code> und in der rechten die Werte <code>value</code>. Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer <code>Map</code> sind eine <code>Set</code>). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). </p> <p>Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung:</p> <p></p>"},{"location":"collections/#der-collection-klassenbaum","title":"Der Collection-Klassenbaum","text":"<p>Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von <code>Collection</code> einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps.</p> <p></p> <p>Die \"Mutter-Klasse\" der Collections <code>List</code> und <code>Set</code> ist <code>Collection</code>. In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces. Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ <code>List</code> f\u00fcr die Listen und den Typ <code>Set</code> f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten <code>List</code>-Objekte bzw. keine konkreten <code>Set</code>-Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes <code>ArrayList</code>-Objekt erzeugen werden oder ein konkretes <code>HashSet</code>-Objekt. Hier einige Beispiele:</p> <pre><code>import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n        List l1 = new ArrayList();\n        List l2 = new LinkedList();\n\n        Set s1 = new HashSet();\n        Set s2 = new TreeSet();\n    }\n}\n</code></pre> <p>Beachten Sie, alle Klassen aus dem <code>java.util</code>-Paket zu importieren! Eine Klasse <code>List</code> gibt es z.B. auch im <code>java.awt</code>-Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben:</p> <pre><code>import java.util.*;\n</code></pre> <p>Der <code>*</code> ist eine Wildcard und importiert alle Klassen aus <code>java.util</code>. </p> <p>Zur Diskussion, wann <code>ArrayList</code> besser ist und wann <code>LinkedList</code>, siehe hier. Eine Diskussion \u00fcber die Unterschiede zwischen <code>HashSet</code> und <code>TreeSet</code> finden Sie z.B. hier. Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von <code>ArrayList</code> erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von <code>HashSet</code>.</p>"},{"location":"collections/#mengen-sets","title":"Mengen - Sets","text":"<p>Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set menge = new HashSet();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        Iterator it = menge.iterator();\n        while(it.hasNext())\n        {\n            System.out.println(it.next());\n        } \n\n    }\n}\n</code></pre> <p>In Zeile <code>1</code> werden zun\u00e4chst alle verwendeten Klassen aus dem <code>java.util</code>-Paket geladen. Das sind f\u00fcr unser Beispiel <code>Set</code>, <code>HashSet</code> und <code>Iterator</code>. Die <code>Iterator</code>-Klasse wird verwendet, um durch unsere Menge <code>menge</code> zu laufen. Wir werden auf den <code>Iterator</code> gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. </p> <p>In Zeile <code>7</code> wird die Menge <code>menge</code> erzeugt. Wir deklarieren daf\u00fcr den Typ <code>Set</code> und erzeugen unter Verwendung des parameterlosen Konstruktors von <code>HashSet</code> ein <code>HashSet</code>-Objekt. Die <code>menge</code> hat also den Compilertyp <code>Set</code> und mindestens den Laufzeittyp <code>HashSet</code> (nat\u00fcrlich noch weitere Laufzeittypen, z.B. <code>Object</code>). </p> <p>In den Zeilen <code>14-17</code> werden der <code>menge</code> Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ <code>String</code>. Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode <code>add(element)</code>. Diese Methode gibt ein <code>boolean</code> zur\u00fcck. Wir lassen in den Zeilen <code>14-17</code> diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: </p> <pre><code>true\ntrue\ntrue\nfalse\n</code></pre> <p>Die <code>add()</code>-Methode gibt also 3x ein <code>true</code> zur\u00fcck und beim vierten Aufruf ein <code>false</code>. Das liegt daran, dass beim vierten Aufruf von <code>add()</code> (Zeile <code>17</code>) das \u00fcbergebene Element <code>s4</code> nicht in die Menge <code>menge</code> eingef\u00fcgt wird, da sich in dieser Menge bereits ein <code>String</code> mit dem Wert <code>\"zweiter\"</code> befindet und eine Menge keine Doppelungen enthalten darf. Da <code>s2.equals(s4)</code> den Wert <code>true</code> zur\u00fcckgibt, erkennt die <code>add()</code>-Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und <code>s4</code> wird deshalb nicht eingef\u00fcgt. </p> <p>In Zeile <code>19</code> lassen wir uns die Anzahl der Elemente in der Menge <code>menge</code> ausgeben. Dies erfolgt mithilfe der <code>size()</code>-Methode (in Collections ist es also nicht <code>length()</code>, auch nicht <code>length</code> und auch nicht <code>getLength()</code> oder <code>getSize()</code>, sondern <code>size()</code>). Der Wert von <code>size()</code> in unserem Beispiel ist <code>3</code>. </p>"},{"location":"collections/#der-iterator","title":"Der Iterator","text":"<p>Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. </p> <p>Die Klasse <code>Iterator</code> besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren):</p> <ul> <li><code>hasNext()</code>: liefert ein <code>true</code> zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann <code>false</code>,</li> <li><code>next()</code>: liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), </li> <li><code>remove()</code>: l\u00f6scht das mit <code>next()</code>zur\u00fcckgegebene Element.</li> </ul> <p>In Zeile <code>21</code> erzeugen wir zun\u00e4chst mit der <code>iterator()</code>-Methode aus <code>Set</code> ein Objekt von <code>Iterator</code>. Die Referenz auf dieses Objekt nennen wir hier <code>it</code>. </p> <p>Die <code>while()</code>-Schleife in den Zeilen <code>22-25</code> durchl\u00e4uft nun diese Iteration, indem sie mithilfe von <code>hasNext()</code> pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von <code>next()</code> aus der Iteration entnommen und in Zeile <code>24</code> auf die Konsole ausgegeben. </p> <p>Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben:</p> <pre><code>zweiter\ndritter\nerster\n</code></pre> <p>Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge <code>\"erster\"</code>, <code>\"zweiter\"</code>, <code>\"dritter\"</code> in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge <code>\"zweiter\"</code>, <code>\"dritter\"</code>, <code>\"erster\"</code>. Auf die Reihenfolge haben wir in Mengen keinen Einfluss!</p>"},{"location":"collections/#methoden-fur-mengen","title":"Methoden f\u00fcr Mengen","text":"<p>Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: <code>add()</code>, <code>size()</code> und <code>iterator()</code>. Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von <code>java.util.Collection</code> erben (erben ist hier eigentlich nicht ganz richtig, da es sich bei <code>java.util.Collection</code> um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection):</p>  Methode   Beschreibung  <code>boolean add(E element)</code>  F\u00fcgt Element <code>element</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>boolean addAll(Collection c)</code>  F\u00fcgt alle Elemente der Collection <code>c</code> in die Collection ein. Gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst <code>false</code>.  <code>void clear()</code>  Entfernt alle Elemente aus der Collection. <code>boolean contains(E element)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich <code>element</code> in der Collection befindet, sonst <code>false</code>. <code>boolean containsAll(Collection c)</code>  Gibt <code>true</code> zur\u00fcck, wenn sich alle Elemente der Collection <code>c</code> in der Collection befinden, sonst <code>false</code>. <code>boolean isEmpty()</code>  Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst <code>false</code>. <code>Iterator iterator()  Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. <code>boolean remove(Object o)</code>  Entfernt <code>o</code> aus der Collection und gibt <code>true</code> zur\u00fcck, wenn ein Element entfernt wurde, sonst <code>false</code>. <code>boolean removeAll(Collection c)</code>  Entfernt alle Elemente aus c aus der Collection und gibt <code>true</code> zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst <code>false</code>. <code>int size()</code>  Gibt die Anzahl der Elemente in der Collection zur\u00fcck. <code>Object[] toArray()</code>  Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. <p>Der TyP <code>E</code> in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem <code>Iterator</code> sehen wir eine neue Syntax <code>&lt;E&gt;</code>. Diese lernen wir gleich kennen. <code>E</code> steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren. </p>"},{"location":"collections/#typisieren","title":"Typisieren","text":"<p>Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun:</p> <pre><code>    Set menge = new HashSet();\n    menge.add(new String(\"erster\"));        // String einf\u00fcgen\n    menge.add(new Power(2,4));              // Power einf\u00fcgen\n    menge.add(new Point(2,3));              // Point einf\u00fcgen\n    menge.add(new Konto());                 // Konto einf\u00fcgen\n</code></pre> <p>Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. </p> <p>Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. </p> <p>Das Typisieren einer Collection erfolgt mithilfe der Diamond-Syntax:  <code>Collection&lt;Typ&gt; name = new KonkreteKlasse&lt;&gt;();</code></p> <p>Wir typisieren die Menge <code>menge</code> aus dem eben gezeigten Beispiel:</p> <pre><code>    Set&lt;String&gt; menge = new HashSet&lt;&gt;();    // mit String typisiert - menge nimmt nur Strings auf\n    menge.add(new String(\"erster\"));        // String einf\u00fcgen\n    menge.add(new Power(2,4));              // Fehler - kein String\n    menge.add(new Point(2,3));              // Fehler - kein String\n    menge.add(new Konto());                 // Fehler - kein String\n</code></pre> <p>Wir haben <code>menge</code> typisiert und angegeben, dass <code>menge</code> nur Objekte vonm Typ <code>String</code> aufnehmen kann. Dazu geben wir bei der Typdeklaration <code>Set&lt;String&gt;</code> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt <code>new HashSet&lt;&gt;();</code>. Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). </p> <p>Der Versuch, Objekte eines anderen Typs als <code>String</code> in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. </p> <p>Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: </p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set&lt;String&gt; menge = new HashSet&lt;&gt;();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        Iterator&lt;String&gt; it = menge.iterator();\n        while(it.hasNext())\n        {\n            System.out.println(it.next());\n        } \n\n    }\n}\n</code></pre> <p>Beachten Sie, dass auch der Iterator (Zeile <code>21</code>) typisiert wird.</p>"},{"location":"collections/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each-Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist:</p> <pre><code>for(TypElement element : collection)\n{\n\n}\n</code></pre> <p>F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    public static void main(String[] args) {\n\n        Set&lt;String&gt; menge = new HashSet&lt;&gt;();\n\n        String s1 = \"erster\";\n        String s2 = \"zweiter\";\n        String s3 = \"dritter\";\n        String s4 = \"zweiter\";\n\n        System.out.println(menge.add(s1)); // true\n        System.out.println(menge.add(s2)); // true\n        System.out.println(menge.add(s3)); // true\n        System.out.println(menge.add(s4)); // false\n\n        System.out.println(menge.size()); // 3\n\n        for(String s : menge)\n        {\n            System.out.println(s);\n        }\n\n    }\n}\n</code></pre> <p>\u00dcbrigens: anstelle der Collection (hier: <code>menge</code>) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each-Schleife verwenden. </p> \u00dcbung <p>Ersetzen Sie im oberen Beispiel <code>HashSet</code> durch <code>TreeSet</code>. Erkennen Sie einen Unterschied?</p>"},{"location":"collections/#listen","title":"Listen","text":"<p>Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von <code>java.util.Collection</code> abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel:</p> <pre><code>import java.util.*;\n\npublic class Collections {\n\n    static void fillList(List&lt;String&gt; list) \n    {\n        for (int i = 0; i &lt; 10; i++) \n        { \n            list.add(String.valueOf(i)); \n        }\n    }\n\n    static void printList(List&lt;String&gt; list) \n    {\n        Iterator&lt;String&gt; it = list.iterator();\n        while(it.hasNext()) \n        {\n            System.out.print(it.next() + \" \");\n        }\n        System.out.println();\n        System.out.println(\"End of list\");\n    }\n\n    public static void main(String[] args)\n    {\n        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n        fillList(list1);\n        printList(list1);\n\n        List&lt;String&gt; list2 = new LinkedList&lt;&gt;();\n        fillList(list2);\n        list2.remove(\"3\");      // Wert!\n        list2.remove(6);        // Index!\n        list1.removeAll(list2);\n        printList(list2);       // 0 1 2 4 5 6 8 9\n        printList(list1);       // 3 7\n    }\n\n}\n</code></pre> <p>Wir erstellen uns zwei Listen <code>list1</code> (Zeile <code>26</code>) und <code>list2</code> (Zeile <code>30</code>). Beide sind vom Compilertyp List und beide sind typisiert mit <code>String</code>, d.h. sie k\u00f6nnen nur Strings aufnehmen. </p> <p>Die Methode <code>fillList()</code> (Zeilen <code>5-11</code>) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern <code>0...9</code>. Da die Liste Strings erwartet, werden die <code>int</code>-Ziffern mithilfe von <code>String.valueOf()</code> in einen <code>String</code> umgewandelt (Zeile <code>9</code>). Die <code>add()</code>-Methode f\u00fcgt die Strings hinzu (Zeile <code>9</code>).  </p> <p>Die Methode <code>printList()</code> (Zeilen <code>13-33</code>) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile <code>18</code>). </p> <p>Der Aufruf von <code>printList(list1);</code> in Zeile <code>28</code> f\u00fchrt zu folgender Ausgabe:</p> <pre><code>0 1 2 3 4 5 6 7 8 9 \nEnd of list\n</code></pre> <p>Die Liste <code>list2</code> wird zun\u00e4chst ebenfalls mit den Ziffern <code>0...9</code> (jeweils als <code>String</code>) bef\u00fcllt. Die Anweisung <code>list2.remove(\"3\");</code> in Zeile <code>32</code> bewirkt, dass der Wert <code>\"3\"</code> aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \n</code></pre> <p>In Zeile <code>33</code> wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index <code>6</code> gespeichert ist. Das ist das Element <code>\"7\"</code>. Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste <code>list2</code> noch folgende Werte:</p> <pre><code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" \n</code></pre> <p>Die Anweisung <code>list1.removeAll(list2);</code> in Zeile <code>34</code> bewirkt nun, dass aus <code>list1</code> alle Werte gel\u00f6scht werden, die (auch) in <code>list2</code> enthalten sind, also <code>\"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\"</code>. Das bewirkt, dass in <code>list1</code> dann nur noch die Werte <code>\"3\" \"7\"</code> \u00fcbrig bleiben. </p> <p>Die Anweisung <code>printList(list2);</code> in Zeile <code>35</code> bewirkt folgende Ausgabe: </p> <pre><code>0 1 2 4 5 6 8 9 \nEnd of list\n</code></pre> <p>Die Anweisung <code>printList(list1);</code> in Zeile <code>36</code> bewirkt folgende Ausgabe: </p> <pre><code>3 7 \nEnd of list\n</code></pre> <p>Die Methode <code>printList()</code> h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each-Schleife implementiert werden k\u00f6nnen:</p> <pre><code>    static void printList(List&lt;String&gt; list) \n    {\n        for(String s : list)\n        {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n        System.out.println(\"End of list\");\n    }\n</code></pre> \u00dcbung <p>Gegeben ist folgender Code: <pre><code>  Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;();\n\u00a0 Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;();\n\n\u00a0 for (int i = 10; i &gt;= 1; i--) { s1.add(i); }\n\u00a0 for (int i = 9; i &lt;= 12; i++) { s2.add(i); }\u000b\n\u00a0 \n\u00a0 s1.addAll(s2); \u00a0 \n</code></pre></p> <ol> <li>Was ist der R\u00fcckgabewert von <code>s1.addAll(s2);</code> und warum?</li> <li>Implementieren Sie die Ausgabe aller Werte von <code>s1</code> und <code>s2</code>. </li> </ol>"},{"location":"collections/#mengenoperationen","title":"Mengenoperationen","text":"<p>Angenommen, wir haben drei Mengen <code>A</code>, <code>B</code> und <code>C</code>, wobei alle Elemente aus <code>C</code> auch Elemente in <code>A</code> sind. Mithilfe der Methoden <code>addAll()</code>, <code>removeAll()</code>, <code>retainAll()</code>  und <code>containsAll()</code> lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt:</p> <p></p>"},{"location":"collections/#stack-und-queue","title":"Stack und Queue","text":"<p>Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen:</p>"},{"location":"collections/#stack","title":"Stack","text":"<ul> <li>Last-In-First-Out-Prinzip</li> <li><code>push(E element)</code> zum Hinzuf\u00fcgen</li> <li><code>pop()</code> entfernt oberstes Element und gibt es zur\u00fcck</li> <li><code>empty()</code> pr\u00fcft, ob der Stack leer ist</li> </ul>"},{"location":"collections/#queue","title":"Queue","text":"<ul> <li>First-In-First-Out-Prinzip</li> <li><code>add()/offer()</code> zum Hinzuf\u00fcgen</li> <li><code>remove()/poll()</code> entfernt vorderstes Element und gibt es zur\u00fcck</li> <li><code>element()/peek()</code> pr\u00fcft, ob die Warteschlange leer ist</li> </ul>"},{"location":"collections/#wertetypen-in-collections","title":"Wertetypen in Collections","text":"<p>Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper-Klassen zur Verf\u00fcgung: <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code>, <code>Boolean</code>:</p> <pre><code>// Wertetypen k\u00f6nnen nicht als konkrete\u00a0\n// Typen in Collections verwendet werden\nList&lt;int&gt; l = new ArrayList&lt;&gt;();    // Fehler !!\n\n// Verwendung der Wrapper-Klassen + Auto-Boxing\nList&lt;Integer&gt; l = new ArrayList&lt;&gt;();\n\nl.add(100);\u00a0 \u00a0 \u00a0 \u00a0 // sogenanntes Auto-Boxing\n</code></pre> <p>Das obere beispiel zeigt in Zeile <code>3</code>, wie es nicht geht. Die <code>List l</code> kann nicht mit <code>int</code> typisiert werden. Stattdessen muss die Wrapper-Klasse <code>Integer</code> verwendet werden. Wir betrachten Wrapper-Klassen im n\u00e4chsten Abschnitt.</p>"},{"location":"enum/","title":"Aufz\u00e4hlungstypen (enum)","text":""},{"location":"enum/#motivation","title":"Motivation","text":"<p>Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B.</p> <pre><code>String tag = \"MONTAG\"   // kann auch Werte \"Dienstag\" usw. annehmen\nint tag = 0;            // Magic Number f\u00fcr \"Montag\"\n</code></pre> <p>Das Problem:  - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. <code>Tag = \"hallo\"</code> oder <code>Tag=4711</code>, - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit</p> Beispiel TicTacToe <pre><code>public class TicTacToe \n{\n    int[][] field;\n\n    TicTacToe()\n    {\n        field = new int[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=0;\n    }\n\n    void makeMove(int i, int j, int player)\n    {\n        if(field[i][j]==0 &amp;&amp; player==1 || player==2)    \n            field[i][j]=player;\n    }\n}\n</code></pre> <ul> <li>Zust\u00e4nde <code>EMPTY</code> (<code>0</code>), <code>RED</code> (<code>1</code>), <code>BLACK</code> (<code>2</code>) verschl\u00fcsselt \u2192 magic numbers</li> <li><code>field[i][j]</code> k\u00f6nnte auch beliebige andere <code>int</code>-Werte annehmen</li> <li>Code nahezu unlesbar</li> </ul>"},{"location":"enum/#erster-verbesserungsversuch-konstanten","title":"Erster Verbesserungsversuch: Konstanten","text":"Beispiel TicTacToe mit Konstanten <pre><code>public class TicTacToe \n{\n    int[][] field;\n    static final int EMPTY = 0;     // Feld ist leer\n    static final int RED = 1;       // auf das Feld hat rot gesetzt\n    static final int BLACK = 2;     // auf das Feld hat schwarz gesetzt\n\n    TicTacToe()\n    {\n        field = new int[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=EMPTY;\n    }\n\n    void makeMove(int i, int j, int player)\n    {\n        if(field[i][j]==EMPTY &amp;&amp; player==RED || player==BLACK)  \n            field[i][j]=player;     // hier wird auf das Feld rot oder schwarz gesetzt\n    }\n}\n</code></pre> <ul> <li>etwas besser, aber immer noch beliebige Werte f\u00fcr <code>field[i][j]</code> m\u00f6glich</li> </ul>"},{"location":"enum/#der-aufzahlungstyp-enum","title":"Der Aufz\u00e4hlungstyp <code>enum</code>","text":"<p>Anforderungen:</p> <ul> <li>eigener Datentyp</li> <li>endliche Anzahl an Zust\u00e4nden bzw. Werten</li> <li>leserliche Bezeichnung der Werte</li> </ul> <p>L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort <code>enum</code></p> <p>Syntax: <pre><code>    enum TypName {WERT1, WERT2, WERT3};\n</code></pre></p> <p>Verwendung: - <code>TypName</code> nun als Datentyp verwendbar, z.B. <code>TypName[][]</code> - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. <code>TypName.WERT1</code></p> Beispiel TicTacToe mit enum <pre><code>public class TicTacToe \n{\n    enum State {EMPTY, RED, BLACK};\n    State[][] field;\n\n    TicTacToe()\n    {\n        field = new State[3][3];\n        for(int i=0; i&lt;field.length; i++)\n            for(int j=0; j&lt;field[i].length; j++)\n                field[i][j]=State.EMPTY;\n    }\n\n    void makeMove(int i, int j, State player)\n    {\n        if(field[i][j]==State.EMPTY &amp;&amp; player!=State.EMPTY)     \n            field[i][j]=player;\n    }\n}\n</code></pre> <ul> <li>typsicher</li> <li>rot und schwarz \u00fcber <code>State.RED</code> und <code>State.BLACK</code> erreichbar</li> <li>andere Zust\u00e4nde nicht m\u00f6glich</li> </ul>"},{"location":"enum/#details","title":"Details:","text":"<ul> <li>alle <code>enum</code> erben implizit von <code>java.lang.Enum</code></li> <li><code>enum</code> sind Referenztypen</li> <li>die Konstanten (Werte) in <code>enum</code> sind automatisch <code>static</code> und <code>final</code></li> <li><code>==</code> kann verwendet werden (auch <code>switch()</code>); <code>equals()</code> gibt es aber auch</li> </ul> Beispiel enum <pre><code>State s = State.EMPTY;  // s = 0 oder s = \"rot\" oder so geht nicht \n                        //-&gt; typsicher\nswitch(s)\n{\n    case EMPTY:     System.out.println(\"leeres Feld\"); break;\n    case RED:   System.out.println(\"roter Stein\"); break;\n    case BLACK:     System.out.println(\"schwarzer Stein Feld\"); break;\n}\n</code></pre>"},{"location":"enum/#weiteres","title":"Weiteres:","text":"<ul> <li>auch Definition von Methoden m\u00f6glich</li> <li><code>toString()</code>, <code>equals()</code> usw. aus <code>Object</code> k\u00f6nnen \u00fcberschrieben werden</li> <li>Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig)</li> <li>Zugriff auf das Array von Konstanten mithilfe von <code>values()</code></li> </ul> Beispiel f\u00fcr Werte mit Attributen <pre><code>enum Farben {\n    KREUZ(12), PIK(11), HERZ(10), KARO(9);\n    private int farbwert;\n\n    private Farben(int wert)\n    {\n        this.farbwert=wert;\n    }   \n\n    @Override\n    public String toString()\n    {\n        char c = ' ';\n        switch(this)\n        {\n            case KREUZ  : c ='\\u2663';  break;\n            case PIK    : c ='\\u2664';  break;\n            case HERZ   : c ='\\u2665';  break;\n            case KARO   : c ='\\u2666';  break;\n        }\n        return String.valueOf(c);\n    }\n}\n</code></pre> noch ein Beispiel f\u00fcr Werte mit Attributen <pre><code>enum Karten {\n    AS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\n    private int kartenwert;\n\n    private Karten(int wert)\n    {\n        this.kartenwert=wert;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"\";\n        switch(this)\n        {\n            case AS     : s =\"A\";   break;\n            case ZEHN   : s =\"10\";  break;\n            case NEUN   : s =\"9\";   break;\n            case ACHT   : s =\"8\";   break;\n            case SIEBEN : s =\"7\";   break;\n            case K      : s =\"K\";   break;\n            case D      : s =\"D\";   break;\n            case B      : s =\"B\";   break;\n        }\n        return s;\n    }\n}\n</code></pre> Ausf\u00fchrliches Beispiel - Skat.java <pre><code>package vorbereitungen.enums;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class Skat {\n    Karte[] p1;\n    Karte[] p2;\n    Karte[] p3;\n    Karte[] skat;\n\n    enum Karten {\n        AS(11), ZEHN(10), NEUN(0), ACHT(0), SIEBEN(0), K(4), D(3), B(2);\n        private int kartenwert;\n\n        private Karten(int wert)\n        {\n            this.kartenwert=wert;\n        }\n\n        @Override\n        public String toString()\n        {\n            String s = \"\";\n            switch(this)\n            {\n                case AS     : s =\"A\";   break;\n                case ZEHN   : s =\"10\";  break;\n                case NEUN   : s =\"9\";   break;\n                case ACHT   : s =\"8\";   break;\n                case SIEBEN : s =\"7\";   break;\n                case K      : s =\"K\";   break;\n                case D      : s =\"D\";   break;\n                case B      : s =\"B\";   break;\n            }\n            return s;\n        }\n    }\n\n    enum Farben {\n        KREUZ(12), PIK(11), HERZ(10), KARO(9);\n        private int farbwert;\n\n        private Farben(int wert)\n        {\n            this.farbwert=wert;\n        }   \n\n        @Override\n        public String toString()\n        {\n            char c = ' ';\n            switch(this)\n            {\n                case KREUZ  : c ='\\u2663';  break;\n                case PIK    : c ='\\u2664';  break;\n                case HERZ   : c ='\\u2665';  break;\n                case KARO   : c ='\\u2666';  break;\n            }\n            return String.valueOf(c);\n        }\n    }\n\n    class Karte {\n        Karten k;\n        Farben f;\n\n        Karte(Karten k, Farben f)\n        {\n            this.k=k;\n            this.f=f;\n        }\n\n        @Override\n        public Karte clone()\n        {\n            return new Karte(this.k,this.f);\n        }\n\n        @Override\n        public String toString()\n        {\n            return f.toString()+k.toString()+\" \";\n        }\n\n    }\n\n    class Deck {\n        Karte[] deck;\n\n        Deck()\n        {\n            deck = new Karte[32];\n            int index = 0;\n            for(Farben f: Farben.values())\n            {\n                for(Karten k:Karten.values())\n                {\n                    deck[index++] = new Karte(k,f);\n                }\n            }\n        }\n\n        @Override\n        public String toString()\n        {\n            String s = \"\";\n            for(int i=0; i&lt;deck.length; i++)\n            {\n                s += deck[i].f.toString() + deck[i].k.toString() +\" \";\n                if(i==7 || i==15 || i==23 || i==31) s+=\"\\n\";\n            }\n            return s;\n        }\n\n        public void print()\n        {\n            System.out.println(this.toString());\n        }\n\n    }\n\n    Skat()\n    {\n        p1 = new Karte[8];\n        p2 = new Karte[8];\n        p3 = new Karte[8];\n        skat = new Karte[2];    \n    }\n\n    boolean existsFalse(boolean[] b)\n    {\n        for(int i=0; i&lt;b.length; i++)\n        {\n            if(!b[i]) return true;\n        }\n        return false;\n    }\n\n    public void geben()\n    {\n        Deck d = new Deck();\n        Random r = new Random();    \n        boolean[] b = new boolean[32]; \n        Arrays.fill(b, false);\n        int indexP1 = 0, indexP2 = 0, indexP3 =0, indexSkat = 0;\n        int zz = r.nextInt(32);\n        while(existsFalse(b))\n        {\n            while(b[zz])\n            {\n                zz = r.nextInt(32);\n            }\n            b[zz] = true;\n            if(indexP1&lt;8)\n            {\n                p1[indexP1++] = d.deck[zz].clone();\n            }\n            else if(indexP2&lt;8)\n            {\n                p2[indexP2++] = d.deck[zz].clone();\n            }\n            else if(indexP3&lt;8)\n            {\n                p3[indexP3++] = d.deck[zz].clone();\n            }\n            else if(indexSkat&lt;2)\n            {\n                skat[indexSkat++] = d.deck[zz].clone();\n            }\n        }\n    }\n\n    public void sortieren()\n    {\n\n    }\n\n    public void print()\n    {\n        System.out.print(\"Spieler 1 : \");\n        for(Karte k : p1) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Spieler 2 : \");\n        for(Karte k : p2) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Spieler 3 : \");\n        for(Karte k : p3) System.out.print(k.toString()+\" \");\n        System.out.println();\n        System.out.print(\"Skat      : \");\n        for(Karte k : skat) System.out.print(k.toString()+\" \");\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Skat s = new Skat();\n        s.geben();\n        s.print();\n\n    }\n\n}\n</code></pre>"},{"location":"enum/#nutzliche-links-fur-enums","title":"N\u00fctzliche Links f\u00fcr enums","text":"<ul> <li>Oracle Docs</li> <li>W3Schools</li> <li>Java enums - so geht's</li> <li>Enums</li> <li>Java Tutorial - Enums (youtube)</li> </ul>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Motivation</p> <p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p> <p>Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf <code>null</code>, erhalten wir eine <code>NullPointerException</code>. Wenn bei einer Nutzereingabe eine Zahl erwartet wird, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls eine Exception geworfen. </p> <p>Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern:</p> <ul> <li>syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das Programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und</li> <li>logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. </li> </ul> <p>Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte, z.B. </p> <ul> <li>fehlerhafte Benutzereingabe </li> <li>Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar </li> <li>gesuchte Datei/Ordner nicht vorhanden usw. </li> </ul> <p>Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt. Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. </p>"},{"location":"exceptions/#try-catch","title":"try-catch","text":"<p>Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem <code>index</code> auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher <code>index</code> aus dem Array ist. Allerdings binden wir diesen Versuch in einen <code>try{}</code>-Block ein. </p> <p>Sollte in einem solchen <code>try{}</code>-Block nun eine Exception geworfen werden, dann fangen wir diese in einem <code>catch(){}</code>-Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus:</p> allgemeine Syntax try-catch <pre><code>try \n{\n    // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n}   \ncatch(Exception e)  \n{\n    // Behandlung der Exception \n}\n</code></pre> <p>Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile <code>3</code> aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem <code>catch</code>-Block, also nach Zeile <code>8</code> weiter. Wenn aber die Anweisung(en) in Zeile <code>3</code> einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile <code>5</code> \"aufgefangen\" und in dem Anweisungsblock in den Zeilen <code>6-8</code> behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. </p>"},{"location":"exceptions/#beispiel-ohne-try-catch","title":"Beispiel ohne try-catch","text":"<p>Wir verdeutlichen dieses Prinzip an einem ersten Beispiel:</p> Beispiel zun\u00e4chst ohne Behandlung der Exceptions <pre><code>class Ausnahmen {\n\n    static char charAt(String s, int index)\n    {\n        char c = s.charAt(index);           // kritisch!\n        return c;\n    }\n    static double divide(int divident, int divisor)\n    {\n        double result = divident/divisor;   // kritisch!\n        return result;\n    }\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    }\n}\n</code></pre> <p>Das Beispiel enth\u00e4lt zwei Methoden <code>charAt()</code> und <code>divide</code>. Der <code>charAt</code>-Methode wird ein <code>String</code> \u00fcbergeben und ein <code>index</code>. Die Methode gibt das Zeichen (<code>char</code>) zur\u00fcck, dass im <code>String</code> unter dem <code>index</code> gespeichert ist (z.B. <code>charAt(\"Hallo\", 1)</code> gibt das <code>'a'</code> zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob <code>index</code> tats\u00e4chlich ein korrekter Index des Strings <code>s</code> ist, d.h. evtl. ist <code>index</code> kleiner als <code>0</code> oder gr\u00f6\u00dfer als die L\u00e4nge von <code>s</code> minus <code>1</code>. Die Anweisung  <code>s.charAt(index);</code> ist somit eine kritische Anweisung, denn sie kann (bei \"falschem\" <code>index</code>) eine <code>StringIndexOutOfBoundsException</code> werfen. </p> <p>Genau so ist die Anweisung <code>divident/divisor;</code> in der Methode <code>divide</code> eine kritische Anweisung, da es sein kann, dass der <code>divisior</code> gleich <code>0</code> ist. Bei der <code>int</code>-Division durch <code>0</code> wird eine <code>ArithmeticException</code> geworfen. </p> <p>Wenn die <code>main</code>-Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile <code>16</code> ab und Zeile <code>17</code> wird gar nicht mehr erreicht: </p> <pre><code>Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n    at packageName.Ausnahmen.divide(Ausnahmen.java:10)\n    at packageName.Ausnahmen.main(Ausnahmen.java:16)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:10</code> und um welche Exception es sich handelt, n\u00e4mlich <code>ArithmeticException: / by zero</code>.</p> <p>Wenn wir in der <code>main</code>-Methode Zeile <code>16</code> auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile <code>17</code> eine Exception wirft, n\u00e4mlich: </p> <pre><code>Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5\n    at java.base/java.lang.StringLatin1.charAt(StringLatin1.java:47)\n    at java.base/java.lang.String.charAt(String.java:702)\n    at packageName.Ausnahmen.charAt(Ausnahmen.java:5)\n    at packageName.Ausnahmen.main(Ausnahmen.java:17)\n</code></pre> <p>Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich <code>Ausnahmen.java:5</code> und um welche Exception es sich handelt, n\u00e4mlich <code>StringIndexOutOfBoundsException: String index out of range: 5</code>. Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile <code>47</code> in der Klasse <code>StringLatin1</code> in der dortigen Methode <code>charAt</code> die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. </p>"},{"location":"exceptions/#beispiel-mit-try-catch","title":"Beispiel mit try-catch","text":"<p>Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir <code>try-catch</code>-Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen:</p> Beispiel mit Behandlung der Exceptions <pre><code>class Ausnahmen {\n\n    static char charAt(String s, int index)\n    {\n        char c = ' ';\n        try\n        {\n            c = s.charAt(index); // kritisch!\n        }\n        catch(StringIndexOutOfBoundsException e)\n        {\n            System.err.println(\"Der Index war ausserhalb des Strings\");\n        }\n        return c;\n    }\n\n    static double divide(int divident, int divisor)\n    {\n        double result = 0.0;\n        try\n        {\n            result = divident/divisor; // kritisch!\n        }\n        catch(ArithmeticException ae)\n        {\n            System.err.println(\"Division durch 0 nicht definiert!\");\n        }\n        return result;\n    }\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    }\n}\n</code></pre> <p>Die kritischen Anweisungen wurden nun jeweils in einen <code>try</code>-Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t <code>out</code> in den <code>println</code>-Anweisungen verwendet, sondern <code>err</code> - Zeilen <code>12</code> und <code>26</code>). </p> <p>Wenn wir das Programm nun ausf\u00fchren (in <code>main</code> muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe:</p> <pre><code>Division durch 0 nicht definiert!\n0.0\nDer Index war ausserhalb des Strings\n</code></pre> <p>Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der <code>divide</code>-Methode wird eine Exception geworfen, dann erfolgt durch Zeile <code>26</code> die Fehlerausgabe auf die Konsole. Danach wird in Zeile <code>28</code> aber <code>result</code> zur\u00fcckgegeben (hat den Wert <code>0.0</code>, den wir bei der Initailisierung in Zeile <code>19</code> angegeben haben) und dieser Wert wird durch Zeile <code>33</code> auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die <code>charAt</code>-Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile <code>34</code> das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. </p> <p>Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:</p>"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","title":"Ablauf einer Ausnahmesituation","text":"<p>Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt:</p> <ol> <li>Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp <code>Exception</code>), wenn eine Exception \"geworfen\" wird</li> <li>Die Abarbeitung des Programmcodes wird sofort unterbrochen.</li> <li>Das Laufzeitsystem sucht nach der n\u00e4chsten <code>catch</code>-Klausel und f\u00fchrt diese aus.</li> <li>Passt die gefundene <code>catch</code>-Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste <code>catch</code>-Klausel gesucht usw.\u00a0</li> </ol> <p>Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen <code>catch</code>-Klausel (Zeile <code>10</code>) ein Objekt vom Typ <code>StringIndexOutOfBoundsException</code> erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von <code>Exception</code> ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von <code>StringIndexOutOfBoundsException</code> allegmein eine <code>Exception</code> erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere <code>catch</code>-Klausel (Zeile <code>24</code>), wo wir eine <code>ArithmeticException</code> erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. Generell gilt, dass man mehrere <code>catch</code>-Bl\u00f6cke hintereinander setzen kann und der erste <code>catch</code>-Block, der dem erwarteten Parametertyp entspricht, wird ausgef\u00fchrt. </p> <p>Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" <code>catch</code>-Klausel gesprungen wird. </p>"},{"location":"exceptions/#ein-weiteres-beispiel","title":"Ein weiteres Beispiel","text":"<p>Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>inputInt()</code>:</p> eine weitere methode inputInt() <pre><code>/*\n * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten\n * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, \n * dann muessen Sie dort noch\n * module ProjektName\n * {\n *  requires java.desktop;\n * }\n * eintragen, damit Sie das Paket javax.swing importieren koennen. \n */\nimport javax.swing.JOptionPane;\n\npublic class Ausnahmen\n{\n    static char charAt(String s, int index)\n    {\n        char c = ' ';\n        try\n        {\n            c = s.charAt(index); // kritisch!\n        }\n        catch(StringIndexOutOfBoundsException e)\n        {\n            System.err.println(\"Der Index war ausserhalb des Strings\");\n        }\n        return c;\n    }\n\n    static double divide(int divident, int divisor)\n    {\n        double result = 0.0;\n        try\n        {\n            result = divident/divisor; // kritisch!\n        }\n        catch(ArithmeticException ae)\n        {\n            System.err.println(\"Division durch 0 nicht definiert!\");\n        }\n        return result;\n    }\n\n    static int inputInt()\n    {\n        int inputInt = 0;\n        boolean inputOk = false;\n        String input =\"\";\n        while(!inputOk)\n        {\n            input = JOptionPane.showInputDialog(\"Zahl :\");\n            inputOk = true;\n            try {\n                inputInt = Integer.parseInt(input);\n            }\n            catch(NumberFormatException e)\n            {\n                inputOk = false;\n            }\n        }\n        return inputInt;\n    }\n\n\n    public static void main(String[] args) \n    {\n        System.out.println(divide(5,0));            // ArithmeticException\n        System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n        System.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\n    }\n}\n</code></pre> <p>Schauen wir uns die Implementierung von <code>inputInt()</code> genauer an: </p> <ul> <li>in Zeile <code>50</code> wird ein kleines Eingabefenster erzeugt (<code>JOptionPane</code> ist eine Klasse aus dem <code>javax.swing</code>-Paket, welches wiederum im Modul <code>java.desktop</code> verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als <code>String</code> zur\u00fcckgegeben und in der Variablen <code>input</code> gespeichert. </li> <li>in Zeile <code>53</code> wird versucht, den Eingabestring <code>input</code> in ein <code>int</code> umzuwandeln. Dazu wird die Methode <code>parseInt()</code> verwendet, die zur Klasse <code>Integer</code> geh\u00f6rt (<code>Integer</code> ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). </li> <li>wenn <code>input</code> eine Zahl enth\u00e4lt, also z.B. so aussieht: <code>\"1234\"</code>, dann erzeugt <code>parseInt()</code> daraus die <code>int</code>-Zahl <code>1234</code> und alles ist ok. Wenn <code>input</code> jedoch keine Zahl enth\u00e4lt, also z.B. <code>\"hallo\"</code>, dann wirft <code>parseInt()</code> eine <code>NumberFormatException</code>, weil die Umwandlung des <code>String</code>s in ein <code>int</code> nicht m\u00f6glich ist. </li> <li>in Zeile <code>55</code> wird eine solche <code>NumberFormatException</code> aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter <code>inputOk</code> auf <code>false</code> gesetzt wird. </li> <li>der gesamte Anweisungsblock Fenster-&gt;Eingabe-&gt;try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von <code>inputOk</code> nicht <code>false</code> ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit <code>parseInt()</code> keine Exception wirft)</li> </ul> <p>\u00dcbrigens k\u00f6nnte die Anweisung <code>inputOk = true;</code> auch nach <code>parseInt()</code> in den <code>try</code>-Block geschrieben werden:</p> <pre><code>static int inputInt()\n{\n    int inputInt = 0;\n    boolean inputOk = false;\n    String input =\"\";\n    while(!inputOk)\n    {\n        input = JOptionPane.showInputDialog(\"Zahl :\");\n\n        try {\n            inputInt = Integer.parseInt(input);\n            inputOk = true;\n        }\n        catch(NumberFormatException e)\n        {\n            inputOk = false;\n        }\n    }\n    return inputInt;\n}\n</code></pre> <p>Zeile <code>12</code> wird nur genau dann erreicht, wenn <code>parseInt()</code> keine Exception wirft. Dann wird auch der <code>catch</code>-Block nicht betreten und die Schleife wird beendet. </p>"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","title":"Beispiel mit mehreren Exceptions","text":"<p>Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende <code>catch</code>-Klausel gesucht wird. Wir erweitern dazu unsere Klasse <code>Ausnahmen</code> um eine weitere Methode <code>mehrereExceptions()</code>:</p> <pre><code>public static void mehrereExceptions()\n{\n    String[] basen = {\"2\", \"8\", \"10\", \"Hi\"};\n    int base = 0;\n    double result= 0;\n    boolean ok = true;\n\n    for(int index = 0; index&lt;=4; index++) \n    {\n        try {\n            base = Integer.parseInt(basen[index]);\n            ok = true;\n        }\n        catch(NumberFormatException nfe) {\n            System.out.println(\"Keine Zahl!\");\n            ok = false;\n        }\n        catch(IndexOutOfBoundsException ioobe) {\n            System.out.println(\"Ausserhalb des Arrays\");\n            ok = false;\n        }\n        for(int exp = 0; exp&lt;6 &amp;&amp; ok; exp++) {\n            result = Math.pow(base, exp);\n            System.out.printf(\"%d ^ %d = %.0f %n\", base, exp, result);\n        }\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>3</code> definieren wir uns ein <code>String[]</code> mit 4 Eintr\u00e4gen. </li> <li>Durch dieses <code>String[]</code> laufen wir mit einer <code>for</code>-Schleife (Zeile <code>8</code>) durch.</li> <li>In Zeile <code>11</code> wandeln wir jeden Eintrag aus dem <code>String[]</code> in eine <code>int</code>-Zahl um. </li> <li>An zwei Stellen k\u00f6nnen Exceptions geworfen werden:<ul> <li>Bei dem Index-basierten Zugriff auf das Array <code>basen[index]</code> in Zeile <code>11</code> kann eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen werden, falls <code>index</code> kein korrekter Index des <code>String[]</code> ist (gilt f\u00fcr <code>index==4</code>).</li> <li>Bei der Umwandlung von <code>String</code> nach <code>int</code> durch <code>parseInt()</code> in Zeile <code>11</code> kann eine <code>NumberFormatException</code> geworfen werden, falls der entsprechende Eintrag im <code>String[]</code> keine Zahl ist (gilt f\u00fcr <code>basen[3]=='Hi'</code>).</li> </ul> </li> </ul> <p>Die Methode erzeugt die folgende Ausgabe:</p> <pre><code>2 ^ 0 = 1 \n2 ^ 1 = 2 \n2 ^ 2 = 4 \n2 ^ 3 = 8 \n2 ^ 4 = 16 \n2 ^ 5 = 32 \n8 ^ 0 = 1 \n8 ^ 1 = 8 \n8 ^ 2 = 64 \n8 ^ 3 = 512 \n8 ^ 4 = 4096 \n8 ^ 5 = 32768 \n10 ^ 0 = 1 \n10 ^ 1 = 10 \n10 ^ 2 = 100 \n10 ^ 3 = 1000 \n10 ^ 4 = 10000 \n10 ^ 5 = 100000 \nKeine Zahl!\nAusserhalb des Arrays\n</code></pre> <p>Das hei\u00dft, dass wenn f\u00fcr <code>parseInt(\"Hi\")</code> eine <code>NumberFormatException</code> geworfen wird, dann wird der <code>catch</code>-Block ausgef\u00fchrt, der eine <code>NumberFormatException</code> erwartet (Zeilen <code>14-17</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt. </p> <p>Wenn f\u00fcr <code>basen[4]</code> eine <code>ArrayIndexOutOfBoundsException</code> geworfen wird, dann wird der  <code>catch</code>-Block ausgef\u00fchrt, der eine <code>IndexOutOfBoundsException</code> erwartet (Zeilen <code>18-21</code>). Der andere <code>catch</code>-Block wird nicht ausgef\u00fchrt.</p> <p>Wir sehen, dass es offensichtlich auch eine <code>IndexOutOfBoundsException</code>-Klasse gibt. Das ist eine Elternklasse von <code>ArrayIndexOutOfBoundsException</code> und auch von <code>StringIndexOutOfBoundsException</code>. Wir schauen uns diese Vererbungshierarchie von <code>Exception</code> nun mal an:</p>"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","title":"Die Vererbungshierarchie der Klasse Exception","text":"<p>Wenn Sie sich die Klasse <code>Exception</code> in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen:</p> <p></p> <p>Alle Exception-Klassen erben von der Klasse <code>Exception</code>, die im <code>java.lang</code>-Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden:</p> <ul> <li>checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen <code>try-catch</code>-Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem <code>try</code>-Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). </li> <li>unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse <code>RunTimeException</code> ab. Wir werden uns genau mit diesen uncheck Exceptions, also von <code>RunTimeException</code> abgeleiteten Klassen besch\u00e4ftigen. </li> </ul> <p>Es gibt von <code>RunTimeException</code> noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die <code>IllegalArgumentException</code>-Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene <code>Exception</code>-Klassen erstellen. </p>"},{"location":"exceptions/#try-catch-finally","title":"try-catch-finally","text":"<p>Prinzipiell besteht das Konstrukt <code>try</code> und <code>catch</code> nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem <code>finally</code>-Block. Der <code>finally</code>-Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt:</p> <pre><code>    try \n    {\n        // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt)\n    }   \n    catch(Exception e)  \n    {\n        // Behandlung der Exception \n    }\n    finally\n    {\n        // Aufraeumen, z.B. Schliessen von Dateien, Beenden von \n        // Verbindungen zu Servern, Datenbanken etc.\n    }\n</code></pre> <p>Typischerweise wird der <code>finally</code>-Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden <code>finally</code> jedoch nicht sehr oft implementieren. </p>"},{"location":"exceptions/#throws-eine-exception-weiterreichen","title":"throws - eine Exception weiterreichen","text":"<p>Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem <code>try-catch</code>-Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort <code>throws</code> verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um <code>throws</code> und danach kommt der entsprechende Typ der Exception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus:</p> <pre><code>[modifizierer] [rueckgabetyp] methodenname throws ExceptionType\n{\n    // Anweisungsblock\n    // wirft (evtl.) Exception\n}   \n</code></pre> <p>Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse <code>Ausnahmen</code> um die Methode <code>getValueAtIndex</code>: </p> <pre><code>static int getValueAtIndex(int[] field, int index) throws ArrayIndexOutOfBoundsException\n{\n    return field[index];\n}\n\n\npublic static void main(String[] args) \n{\n    System.out.println(divide(5,0));            // ArithmeticException\n    System.out.println(charAt(\"Hallo\", 5));     // StringIndexOutOfBoundsException\n    System.out.println(\"Zahl: \" + inputInt());  // NumberFormatException\n    mehrereExceptions();\n\n    int value = 0;\n    boolean ok = true;\n    int[] field = {8, 3,-4, 2, -9};\n    try\n    {\n        value = getValueAtIndex(field,-3);\n    }\n    catch(ArrayIndexOutOfBoundsException e)\n    {\n        System.out.println(\"Index ausserhalb des Arrays!\");\n        ok = false;\n    }\n    if(ok) \n    {\n        System.out.println(\"value : \" + value);\n    }\n}\n</code></pre> <p>Obwohl die Methode eine kritische Anweisung enth\u00e4lt (<code>field[index]</code>), ist diese Anweisung nicht in einen <code>try-catch</code>-Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine <code>ArrayIndexOutOfBoundsException</code>) geworfen wird. Wir geben das im Methodenkopf mithilfe von <code>throws ArrayIndexOutOfBoundsException</code> bekannt. Die aufrufende Methode (<code>main</code>) kann nun selbst den Aufruf der Methode <code>getValueAtIndex()</code> in einen <code>try-catch</code>-Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode <code>getValueAtIndex()</code> zur\u00fcckgegebene Wert ausgegeben. </p> <p>Wenn wir an unsere einleitenden Beispiele denken (Methoden <code>charAt()</code> und <code>divide()</code>), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von <code>getValueAtIndex()</code> vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei <code>charAt()</code>. Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. </p>"},{"location":"exceptions/#schoner-code","title":"Sch\u00f6ner Code","text":"<p>Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. </p> <p>Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: </p> <ol> <li>eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP)</li> <li>\u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich)</li> <li>\u2192 lassen Sie Methode, die etwas erledigt, eine Exception werfen und leiten Sie diese weiter (<code>throws</code>) </li> <li>\u2192 fangen Sie den Fehler in einer anderen Methode ab (<code>try</code>)</li> <li>\u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers (<code>catch</code>) in eine dritte Methode auslagern (single responsibility)</li> </ol> <p>H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt (<code>try</code>) im <code>catch</code>-Block den Fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. </p>"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","title":"throw - eigene Exceptions erzeugen","text":"<p>Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich <code>throw</code>. Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort <code>throws</code> sehr \u00e4hnlich. Mit <code>throw</code> erzeugen (werfen) wir eine eigene Exception, mit <code>throws</code> wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. </p> <p>Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe <code>Triangle</code>im ersten Semester bereits \u00fcberlegt, dass dadurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. Das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird?</p> <p>Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes <code>throw</code> wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja (\"automatisch\" durch die Laufzeitumgebung) geworfen. </p> <p>F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten:</p> <ul> <li>entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse <code>Exception</code> oder von der Klasse <code>RunTimeException</code> ab (<code>extends Exception</code> bzw. <code>extends RunTimeException</code>) oder</li> <li>wir verwenden eine bereits existierende Exception-Klasse (typischerweise <code>IllegalArgumentException</code>).</li> </ul>"},{"location":"exceptions/#throw-new-illegalargumentexception","title":"throw new IllegalArgumentException","text":"<p>Wir implementieren unsere Klasse <code>Triangle</code> so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine <code>IllegalArgumentException</code> werfen. Dieser Exception kann ein <code>String</code> als Parameter \u00fcbergeben werden, der im <code>catch</code>-Block mittels <code>getMessage()</code> wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist.</p> Triangle mit eigenen IllegalArgumentExceptions <pre><code>public class Triangle\n{\n    private int a,b,c;\n\n    public Triangle(int a, int b, int c) throws IllegalArgumentException\n    {\n        if(a&lt;=0 || b&lt;=0 || c&lt;=0) \n        {\n            throw new IllegalArgumentException(\"Seiten muessen groesser als 0 sein!\");\n        }\n        else if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) \n        {\n            throw new IllegalArgumentException(\"Kein Dreieck!\");\n        }\n        else \n        {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n    public static void main(String[] args) \n    {\n        Triangle d;\n\n        try {\n            d = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n        }\n        catch(IllegalArgumentException e) \n        {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile <code>5</code> - <code>throws IllegalArgumentException</code>). Im Konstruktor werden die Parameterwerte gepr\u00fcft und</p> <ul> <li>entweder eine <code>IllegalArgumentException</code> geworfen, falls eine Seite kleiner gleich 0 ist (Zeile <code>9</code> - <code>throw new</code>) </li> <li>oder eine <code>IllegalArgumentException</code> geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile <code>13</code> - <code>throw new</code>) </li> <li>oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen <code>17-19</code>).</li> </ul> <p>Die Erzeugung eines <code>Triangle</code>-Objektes (also der Aufruf des Konstruktors) ist nun in einen <code>try-catch</code>-Block eingebettet (Zeilen <code>26-32</code>). Beachten Sie, dass es sein kann, dass <code>d</code> nach Aufruf des Konstruktors immernoch <code>null</code> ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.</p>"},{"location":"exceptions/#eigene-exception-klasse-definieren","title":"Eigene Exception-Klasse definieren","text":"<p>Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von <code>Triangle</code>. Diese eigenen Exception-Klassen erben von der Klasse <code>Exception</code>. Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem <code>try-catch</code>-Block abgefangen und behandelt werden. </p> Eigene Klasse IllegalTriangleException <pre><code>public class IllegalTriangleException extends Exception\n{\n    public IllegalTriangleException(String s) {\n        super(s);\n    }\n\n    public IllegalTriangleException() {\n        super(\"Each side has to be smaller than the sum of the other sides!\");\n    }\n}\n</code></pre> <p>Die Klasse <code>IllegalTriangleException</code> verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. </p> Eigene Klasse IllegalSideLengthException <pre><code>public class IllegalSideLengthException extends Exception\n{\n\n    public IllegalSideLengthException(String s) {\n        super(s);\n    }\n\n    public IllegalSideLengthException() {\n        super(\"Sides must be greater than zero!\");\n    }\n}\n</code></pre> <p>Die Klasse <code>IllegalSideLengthException</code> verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von <code>Exception</code> erzeugt und dem eine Fehlermeldung als <code>String</code> im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als <code>String</code> \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. </p> <p>Die Anwendung dieser beiden Exception-Klassen in der Klasse <code>Triangle</code> k\u00f6nnte nun so aussehen (wir haben hier auch gleich die <code>main</code>-Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen):</p> Triangle mit den selbst definierten Exception-Klassen <pre><code>public class Triangle\n{\n    private int a,b,c;\n\n    public Triangle(int a, int b, int c) throws Exception\n    {\n        if(a&lt;=0 || b&lt;=0 || c&lt;=0) \n        {\n            throw new IllegalTriangleException();\n        }\n        else if(a&gt;=(b+c) || b&gt;=(a+c) || c&gt;=(a+b)) \n        {\n            throw new IllegalSideLengthException();\n        }\n        else \n        {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        Triangle d;\n\n        try {\n            d = new Triangle(3,4,5);        //(3,4,0) und (3,4,8) probieren\n        }\n        catch(Exception e) \n        {\n            System.out.println(e.getMessage());\n        }\n\n    }\n}\n</code></pre> <p>Beide eigenen Klassen sind ja auch vom Laufzeittyp <code>Exception</code>, da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der <code>catch</code>-Klausel mit <code>Exception</code> (Zeile <code>30</code>) passend. Wenn Sie anstelle der Zeilen <code>27-33</code> nur <code>d = new Triangle(3,4,5);</code> schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem <code>try-catch</code>-Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an <code>Surround with try/catch</code>. Das sollten Sie einmal ausprobieren. </p> <p>Wenn Sie anstelle von <code>Exception</code> von der Klasse <code>RunTimeException</code> erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden.</p> <p>Success</p> <p>Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von <code>Exception</code>, insb. von <code>RunTimeException</code>). Mithilfe von <code>try-catch-[finally]</code> k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von <code>throws</code> zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort <code>throw</code> weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem <code>try-catch</code>-Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...</p>"},{"location":"git/","title":"Git","text":"<p>Git ist ein Versionierungswerkzeug f\u00fcr die Softwareentwicklung. Mit Git k\u00f6nnen Sie</p> <ul> <li>Ihre Software versionieren, d.h. Versionen Ihrer Software erstellen und zwischen diesen Versionen hin- und herwecheseln sowie</li> <li>im Team gemeinsam an einem Softwareprojekt arbeiten und die einzelnen Entwicklungen aller Teammitglieder geeignet zusammenf\u00fchren. </li> </ul> <p>Git ist Open Source und frei verf\u00fcgbar. Entstanden ist Git im Rahmen der Entwicklung von Linux, initiiert durch Linus Torvalds, dem Initiator von Linux.</p>"},{"location":"git/#installation-von-git","title":"Installation von Git","text":"<p>Um Git verwenden zu k\u00f6nnen, m\u00fcssen Sie es zun\u00e4chst installieren. Laden Sie sich Git f\u00fcr Ihr Betriebssystem von der Download-Seite herunter bzw. gehen Sie so vor, wie f\u00fcr Ihr Betriebssystenm beschrieben. Installationshilfen erhalten Sie z.B. auch im frei verf\u00fcgbaren Git-Buch unter Git installieren oder auch im Video \u00fcber die ersten Schritte mit Git. </p> <p>Wenn Sie unter Windows arbeiten, dann erhalten Sie mit Git eine <code>GitBash</code>. Wenn wir von nun an vom <code>Terminal</code> (oder <code>Shell</code> oder <code>Bash</code>) sprechen, dann verwenden Sie bitte immer diese <code>GitBash</code>. </p> <p>Nach erfolgreicher Installation k\u00f6nnen Sie im Terminal den Befehl</p> <pre><code>git --version\n</code></pre> <p>eingeben und es sollte eine Ausgabe, wie</p> <pre><code>git version 2.30.1\n</code></pre> <p>oder eine aktuellere Versionsnummer erfolgen.</p> <p>Wir k\u00f6nnen Git nun verwenden und betrachten zun\u00e4chst, wie Git als Versionierungswerkzeug verwendet werden kann und schauen uns danach an, wie es als Kollaborationswerkzeug verwendet wird. </p>"},{"location":"git/#git-als-versionierungswerkzeug","title":"Git als Versionierungswerkzeug","text":"<p>Die grunds\u00e4tzliche Idee von Git ist, \u00c4nderungen an Dateien und Ordnern so zu speichern, dass alle diese \u00c4nderungen nachverfolgbar sind. Git erzeugt sogenannte Snapshots aller Dateien und Ordner und speichert diese Snapshots nacheinander lokal ab. D.h. alles passiert bei Ihnen lokal auf dem Rechner, Sie ben\u00f6tigen keine Verbindung zu einem Server. Wenn Sie sp\u00e4ter im Team zu Mehreren an einem Projekt arbeiten, dann gleichen Sie immer nur die Historien Ihrer Snapshots ab. Git f\u00fcgt immer nur hinzu und das ist auch korrekt so. Selbst, wenn in sp\u00e4teren Versionen Ihres eine Datei nicht mehr existiert, die in fr\u00fcheren Versionen des Projektes noch existierte, soll diese Datei gar nicht gel\u00f6scht werden, denn es k\u00f6nnte ja sein, dass Sie irgendwann nochmal die fr\u00fchere Version anschauen wollen, die die Datei enthielt. </p> <p>Dieses Skript hier z.B. verwalte ich mit Git. Das bedeutet, dass alle Dateien eines Ordners (und Unterordnern) in einem sogenannten Git-Repository (oder nur Repository) verwaltet werden. F\u00fcr dieses Skript hier k\u00f6nnte das z.B. so aussehen:</p> <p></p> <p>Das hei\u00dft, ich erstelle zun\u00e4chst 3 Dateien: <code>Einf\u00fchrung</code>, <code>Wiederholung</code> und <code>Git</code> und \"sage\" Git, dass dies <code>Version1</code> sein soll. Danach f\u00fcge ich 3 weitere Dateien hinzu <code>Aufgaben</code>, <code>\u00dcbungen</code> und <code>Wrapperklassen</code> und zusammen mit den vorherigen 3 Dateien aus Version 1 ergibt das dann <code>Version 2</code>. Danach \u00e4ndere ich (f\u00fcge hinzu) die Dateien <code>Aufgaben</code> und <code>\u00fcbungen</code> und f\u00fcge au\u00dferdem neue Dateien f\u00fcr <code>Exceptions</code> und <code>JUnit</code> hinzu und \"sage\", dass das insgesamt <code>Version 3</code> ergibt usw. Git verwaltet nun diese Versionen und der Vorteil ist, dass ich jede dieser Versionen separat zur Verf\u00fcgung stellen k\u00f6nnte und auch auf diesen Versionen weiterarbeiten. Wir werden in Zukunft in Bezug auf Git aber nicht mehr unbedingt von Versionen sprechen, sondern von Snapshots. Wir schauen uns das nun in einem Besipiel an. </p>"},{"location":"git/#git-init-ein-repository-erstellen","title":"git init - ein Repository erstellen","text":"<p>Angenommen, wir haben in unserem <code>workspace</code> folgende Ordner-Struktur:</p> <p></p> <p>In dem <code>workspace</code> gibt es ein Projekt <code>Projekt1</code> und darin einen <code>src</code>-Ordner mit unseren <code>*.java</code>-Dateien und einen <code>bin</code>-Ordner mit unseren <code>*.class</code>-Dateien. Wir lassen f\u00fcr dieses einf\u00fchrende Beispiel einmal Pakete weg. Diese w\u00fcrden ja als Ordner-Struktur sowohl innerhalb von <code>src</code> als auch von <code>bin</code> auftauchen. So sieht also ein typischer <code>workspace</code> aus. Es gibt darin noch weitere Ordner und Dateien, wie z.B. <code>.idea</code>, <code>.metadata</code>, <code>.classpath</code>, <code>.project</code>, <code>.settings</code>, die von unseren Entwicklungsumgebungen (Eclipse, IntelliJ, ...) angelegt wurden. </p> <p>Wir wollen nun unseren <code>workspace</code> von Git verwalten lassen. Dazu wechseln wir im Terminal in den <code>workspace</code>-Ordner und f\u00fchren dort das Kommando</p> <pre><code>git init\n</code></pre> <p>aus. Dieses Kommando erstellt das Git-Repository. Es muss genau einmal, n\u00e4mlich ganz am Anfang zur Erstellung des Repositorys ausgef\u00fchrt werden. Im Terminal erscheint</p> <pre><code>Hinweis: Als Name f\u00fcr den initialen Branch wurde 'master' benutzt. Dieser\nHinweis: Standard-Branchname kann sich \u00e4ndern. Um den Namen des initialen Branches\nHinweis: zu konfigurieren, der in allen neuen Repositories verwendet werden soll und\nHinweis: um diese Warnung zu unterdr\u00fccken, f\u00fchren Sie aus:\nHinweis: \nHinweis:    git config --global init.defaultBranch &lt;Name&gt;\nHinweis: \nHinweis: H\u00e4ufig gew\u00e4hlte Namen statt 'master' sind 'main', 'trunk' und\nHinweis: 'development'. Der gerade erstellte Branch kann mit diesem Befehl\nHinweis: umbenannt werden:\nHinweis: \nHinweis:    git branch -m &lt;Name&gt;\nLeeres Git-Repository in /...IhrPfadZumWorkspaceOrdner.../workspace/.git/ initialisiert\n</code></pre> <p>Somit wurde ein Git-Repository erstellt. Der <code>workspace</code>-Ordner wird nun von Git verwaltet. Dies erkennen Sie daran, dass in dem <code>workspace</code>-Ordner ein <code>.git</code>-Ordner angelegt wurde:</p> <p></p> <p>Klicken Sie ruhig mal in den Ordner, um zu sehen, was da alles drin ist.</p>"},{"location":"git/#gitignore-dateien-aus-der-verwaltung-ausschlieen","title":".gitignore - Dateien aus der Verwaltung ausschlie\u00dfen","text":"<p>Git w\u00fcrde nun den gesamten <code>workspace</code>-Ordner verwalten. Das w\u00e4re zun\u00e4chst auch gar kein Problem. Aber wenn Sie im Team zu mehreren am selben Projekt (workspace) arbeiten, dann wollen Sie bestimmte Dateien gar nicht untereinander austauschen, z.B. alle Dateien, die von Ihrer IDE erstellt wurden (z.B. <code>.idea</code>, <code>.metadata</code>, <code>.classpath</code>, <code>.project</code>, <code>.settings</code>). Auch alle Dateien im <code>bin</code>-Ordner m\u00fcssen nicht von Git verwaltet werden, weil Sie ja stets neu durch das Compilieren erzeugt werden. </p> <p>Noch bevor wir nun also unsere erste Version erzeugen wollen, schlie\u00dfen wir zun\u00e4chst einige Ordner und Dateien aus der Verwaltung von Git aus. Dazu wird im <code>workspace</code>-Ordner eine Datei <code>.gitignore</code> erstellt, in die wir alle Dateien und Ordner eintragen, die wir aus der Git-Verwaltung ausschlie\u00dfen wollen. Bevor wir das machen, geben wir im Terminal in unserem <code>workspace</code>-Ordner einmal den Befehl </p> <pre><code>git status\n</code></pre> <p>ein. Dies wird der am meisten verwendete Befehl f\u00fcr uns sein, der mit dem Befehl bekommen wir Auskunft \u00fcber den aktuellen Status des Repositorys. Die Ausgabe derzeit ist</p> <pre><code>Auf Branch master\n\nNoch keine Commits\n\nUnversionierte Dateien:\n  (benutzen Sie \"git add &lt;Datei&gt;...\", um die \u00c4nderungen zum Commit vorzumerken)\n    .DS_Store\n    .idea/\n    .metadata/\n    Projekt1/\n\nnichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien\n(benutzen Sie \"git add\" zum Versionieren)\n</code></pre> <p>Das m\u00fcssen wir zum jetzigen Zeitpunkt noch nicht alles verstehen, aber wir sehen, dass Git derzeit die Datei <code>.DS_Store</code> und die Ordner <code>.idea/</code>, <code>.metadata/</code> und <code>Projekt1/</code> verwaltet und wir ja eigentlich nur die Verwaltung von <code>Projekt1/</code> w\u00fcnschen (und darin auch nicht alles). Wir erstellen uns also im <code>workspace</code>-Ordner eine <code>.gitignore</code>-Datei und geben darin ein:</p> <pre><code>.DS_Store\n.idea\n.metadata\nProjekt1/bin\nProjekt1/.classpath\nProjekt1/.project\nProjekt1/.settings\n</code></pre> <p>Damit geben wir an, dass die Datei <code>.DS_Store</code> ignoriert werden soll (gibt es nur unter Mac - legt der Finder automatisch zur schnelleren Suche an) sowie die Ordner <code>.idea</code> und <code>.metadata</code>. H\u00e4tten wir <code>.idea/</code> und <code>.metadata/</code> geschrieben, w\u00fcrde der Ordner jeweils selbst mit in der Git-Verwaltung sein, jedoch der Kontent nicht. Ansonsten soll auch noch der Ordner <code>Projekt1/bin</code> aus der Git-Verwaltung entfernt werden und alle Dateien und Ordner, die mit einem Punkt beginnen und im Ordner <code>Projekt1</code> liegen.</p> <p>Wenn man alle Dateien ignorieren m\u00f6chte, die mit einem Punkt beginnen, egal in welchem ordner, dann k\u00f6nnte man auch <code>.*</code> in die <code>.gitignore</code> schreiben. Dann w\u00fcrde allerdings auch die <code>.gitignore</code> selbst dazugeh\u00f6ren. Diese kann und sollte man aber ruhig mit in die Git-Verwaltung aufnehmen. Eine \u00dcbersicht \u00fcber m\u00f6gliche Eintr\u00e4ge in die <code>.gitignore</code> findet man z.B. hier oder hier.</p> <p>Wenn wir jetzt erneut </p> <pre><code>git status\n</code></pre> <p>eingeben, dann ist die Ausgabe:</p> <pre><code>Auf Branch master\n\nNoch keine Commits\n\nUnversionierte Dateien:\n  (benutzen Sie \"git add &lt;Datei&gt;...\", um die \u00c4nderungen zum Commit vorzumerken)\n    .gitignore\n    Projekt1/\n\nnichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien\n(benutzen Sie \"git add\" zum Versionieren)\n</code></pre> <p>D.h. wir sehen, dass die Dateien und Ordner <code>.DS_Store</code>, <code>.idea/</code> und <code>.metadata/</code> nun nicht mehr mit verwaltet werden, daf\u00fcr aber die <code>.gitignore</code>.</p> <p>Wir haben jetzt ein Git-Repoitory, aber es ist noch leer. Wir f\u00fcgen nun Dateien diesem Repository hinzu. </p>"},{"location":"git/#git-add-dem-repository-dateien-hinzufugen","title":"git add - dem Repository Dateien hinzuf\u00fcgen","text":"<p>Wir haben noch keine Ordner und Dateien in unser Repository aufgenommen, d.h. es werden noch keine \u00c4nderungen an diesen Dateien durch Git verwaltet. Um Dateien dem Repository hinzuzuf\u00fcgen, verwenden wir das Kommando git add. Wir wollen den Ordner <code>Projekt1</code> und die Datei <code>.gitignore</code> dem Repository hinzuf\u00fcgen, um sie von nun an von Git verwalten zu lassen (d.h. ihre \u00c4nderungen zu \"protokollieren\").</p> <p>Wir geben im Terminal im <code>workspace</code>-Ordner ein:</p> <pre><code>git add .gitignore\ngit add Projekt1\n</code></pre> <p>und f\u00fcgen somit den gesamten Ordner <code>Projekt1</code> (aber nicht die in der <code>.gitignore</code> definierten Dateien und Ordner aus dem Ordner <code>Projekt1</code>) und die <code>.gitignore</code>-Datei dem Repository hinzu.  </p> <pre><code>git status\n</code></pre> <p>ergibt nun:</p> <pre><code>Auf Branch master\n\nNoch keine Commits\n\nZum Commit vorgemerkte \u00c4nderungen:\n  (benutzen Sie \"git rm --cached &lt;Datei&gt;...\" zum Entfernen aus der Staging-Area)\n    neue Datei:     .gitignore\n    neue Datei:     Projekt1/src/A.java\n    neue Datei:     Projekt1/src/B.java\n</code></pre> <p>D.h. von nun an werden von Git die Dateien <code>.gitignore</code>, <code>Projekt1/src/A.java</code> und <code>Projekt1/src/B.java</code> verwaltet. Die Dateien <code>A.java</code> und <code>B.java</code> sind jetzt noch leer. </p> <p>Wann immer wir eine neue Datei in unserem <code>workspace</code> erstellen und wir wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei mit <code>git add &lt;datei&gt;</code> dem repository hinzu!</p> <p>Wann immer wir eine neue Datei in unserem <code>workspace</code> erstellen und wir nicht wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei der <code>.gitignore</code>-Datei hinzu!</p> <p>Mit dem Befehl</p> <pre><code>git add .\n</code></pre> <p>werden einfach immer alle neuen Dateien hinzugef\u00fcgt. Wir werden diesen Befehl h\u00e4ufig nutzen, um nicht alle neuen Dateien einzeln aufzulisten. Es gibt f\u00fcr <code>add</code> auch die Option <code>--all</code> (<code>-A</code>), mit der alle Dateien aus einem Ordner hinzugef\u00fcgt werden.</p>"},{"location":"git/#git-commit-einen-snapshot-erstellen","title":"git commit - einen Snapshot erstellen","text":"<p>Mit <code>git commit</code> \"speichern\" wir das gesamte Repository. Git merkt sich den Stand aller Dateien und Ordner und den Zeitpunkt des Commits. Zus\u00e4tzlich geben wir zum <code>git commit</code> noch eine Commit-Nachricht an, um den Stand der Arbeit zu beschreiben. In einem Snapshot werden alle \u00c4nderungen im Vergleich zum vorherigen Snapshot gespeichert. Man kann sich also die Versionierung mit Git wie eine Reihe von Commits (Snapshots) vorstellen:</p> <p></p> <p>Ganz am Anfang ein initiales Commit (<code>C0</code>), dann wurde weiter gearbeitet und ein weiteres Commit (<code>C1</code>) gesetzt und so weiter (<code>C2</code>). Es ist ohne Probleme m\u00f6glich, wieder zum Stand von <code>C1</code> oder sogar <code>C0</code> \"zur\u00fcckzuspringen\" (zeigen wir sp\u00e4ter, wie). </p> <p>Zun\u00e4chst erstellen wir unser initiales Commit. Dazu geben wir im Terminal im <code>workspace</code>-Ordner ein:</p> <pre><code>git commit -m \"Initiales Commit. A.java und B.java jeweils leer.\"\n</code></pre> <p>es erscheint die Ausgabe:</p> <pre><code>[master (Root-Commit) 8236e8a] Initiales Commit. A.java und B.java jeweils leer.\n 3 files changed, 8 insertions(+)\n create mode 100644 .gitignore\n create mode 100644 Projekt1/src/A.java\n create mode 100644 Projekt1/src/B.java\n</code></pre> <p>Unser erstes Commit (das sogenannte Root-Commit) wurde erstellt. Wir haben jetzt einen \"gespeicherten\" Ausgangszustand, zu dem wir immer wieder zur\u00fccksetzen k\u00f6nnten. Unser \"Entwicklungsstrang\" nennt sich Branch. Der Hauptstrang, an dem wir versuchen, alle Entwicklungen immer ordentlich zusammenzuf\u00fchren, nennt sich master-Branch. Das letzte Commit ist stets der <code>HEAD</code>. Derzeit ist unser <code>HEAD</code> also dieses initiale Commit. Die Begriffe sind in der folgenden Abbildung dargestellt:</p> <p></p> <p>Wir \u00e4ndern nun mal die Datei <code>Projekt1/src/A.java</code> und f\u00fcgen dort einfach ein Zeilenkommentar</p> <pre><code>// Zeile 1 hinzugefuegt\n// \n</code></pre> <p>hinzu. Wenn wir nun <code>git status</code> aufrufen, erscheint</p> <pre><code>Auf Branch master\n\u00c4nderungen, die nicht zum Commit vorgemerkt sind:\n  (benutzen Sie \"git add &lt;Datei&gt;...\", um die \u00c4nderungen zum Commit vorzumerken)\n  (benutzen Sie \"git restore &lt;Datei&gt;...\", um die \u00c4nderungen im Arbeitsverzeichnis zu verwerfen)\n    ge\u00e4ndert:       Projekt1/src/A.java\n\nkeine \u00c4nderungen zum Commit vorgemerkt (benutzen Sie \"git add\" und/oder \"git commit -a\")\n</code></pre> <p>Wir k\u00f6nnen diese \u00c4nderung nun committen, indem wir die Option <code>-a</code> verwenden (oder zuvor <code>git add Projekt1/src/A.java</code>):</p> <pre><code>git commit -am \"in A.java Zeile 1 hinzugefuegt\"\n</code></pre> <p>Wir erhalten die Ausgabe:</p> <pre><code>[master 44ed3a8] in A.java Zeile 1 hinzugefuegt\n 1 file changed, 2 insertions(+)\n</code></pre> <p>Wir haben jetzt einen neuen <code>HEAD</code>, nicht mehr das Root-Commit mit der \"Nummer\" <code>8236e8a</code>, sondern nun dieses zweite Commit mit der \"Nummer\" <code>44ed3a8</code>. Diese Nummern sind Hash-Werte. Tats\u00e4chlich sind diese Hash-Werte sogar l\u00e4nger. Wir k\u00f6nnen Sie uns mit <code>git log</code> anzeigen lassen.</p>"},{"location":"git/#git-log-und-git-show","title":"git log und git show","text":"<p>Mit <code>git log</code> k\u00f6nnen Sie sich alle Ihre Commits auflisten lassen. In unserem jetzigen Zustand erzeugt <code>git log</code> folgende Ausgabe:</p> <pre><code>commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd (HEAD -&gt; master)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 18:13:48 2021 +0200\n\n    in A.java Zeile 1 hinzugefuegt\n\ncommit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 08:42:37 2021 +0200\n\n    Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>Wenn Ihnen diese Ansicht zu un\u00fcbersichtlich ist, k\u00f6nnen Sie die Option <code>--oneline</code> verwenden:</p> <pre><code>git log --oneline\n</code></pre> <p>erzeugt:</p> <pre><code>44ed3a8 (HEAD -&gt; master) in A.java Zeile 1 hinzugefuegt\n8236e8a Initiales Commit. A.java und B.java jeweils leer.\n</code></pre>"},{"location":"git/#git-branch-und-git-ckeckout-branches-in-git","title":"git branch und git ckeckout - Branches in Git","text":"<p>Unser Repository sieht derzeit so aus:</p> <p></p> <p>Angenommen, wir wollen etwas ausprobieren und unabh\u00e4ngig von dem Hauptentwicklungsstrang (dem master-Branch) z.B. an <code>Projekt1/src/B.java</code> arbeiten, ohne aber den bisherigen Stand zu \"gef\u00e4rden\". Dazu gibt es die M\u00f6glichkeit, neue, eigene Branches zu erstellen. Diese gehen von einem Commit des master-Branches aus und k\u00f6nnen sp\u00e4ter auch wieder auf den master-Branch f\u00fchren (oder, falls unser Ausprobieren doch nicht erfolgreich war, auch nicht).</p> <p>Einen neuen Branch erstellen wir mit <code>git branch &lt;nameDesNeuenBranches&gt;</code>. Wir erstellen uns einen Branch <code>tryB</code>:</p> <pre><code>git branch tryB\n</code></pre> <p>Dabei passiert erstmal noch gar nichts. Es wird nur ein Link auf das letzte Commit (den <code>HEAD</code>) erzeugt und dieser Link hei\u00dft <code>tryB</code>. Wenn wir jetzt einfach erstmal an <code>Projekt1/src/A.java</code> weiterarbeiten w\u00fcrden und die \u00c4nderungen committen, stellen wir fest, dass wir tats\u00e4chlich am master-Branch weiterarbeiten. Um das zu zeigen, \u00e4ndern wir die Datei <code>Projekt1/src/A.java</code> und f\u00fcgen einen weiteren Zeilenkommentar hinzu.</p> <pre><code>// Zeile 1 hinzugefuegt\n// Zeile 2 hinzugefuegt\n//\n</code></pre> <p>Wir wissen bereits, wie wir diese \u00c4nderung committen:</p> <pre><code>git commit -am \"in A.java Zeile 2 hinzugefuegt\"\n</code></pre> <p><code>git log</code> ergibt:</p> <pre><code>commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde (HEAD -&gt; master)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Sat Apr 3 09:09:54 2021 +0200\n\n    in A.java Zeile 2 hinzugefuegt\n\ncommit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd (tryB)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 18:13:48 2021 +0200\n\n    in A.java Zeile 1 hinzugefuegt\n\ncommit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 08:42:37 2021 +0200\n\n    Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>Das zeigt uns, dass wir am master-Branch weitergearbeitet haben und dass <code>HEAD</code> auf den master-Branch zeigt. Wir sehen aber auch, dass wir auf dem zweiten Commit einen Link <code>tryB</code> haben. Wir wollen jetzt aber auf diesem <code>tryB</code>-Branch arbeiten und nutzen dazu den Befehl <code>git checkout &lt;branch&gt;</code>:</p> <pre><code>git checkout tryB\n</code></pre> <p>Damit haben wir 2 Sachen getan:</p> <ol> <li>arbeiten wir jetzt auf einem anderen Branch, als dem master-Branch, n\u00e4mlich dem tryB-Branch und</li> <li>setzen wir auf den Zustand auf, den wir mit dem Commit gespeichert hatten (<code>44ed3a8</code>), auf den <code>tryB</code> zeigt. </li> </ol> <p>Den 2. Punkt k\u00f6nnen wir \u00fcberpr\u00fcfen, indem wir uns die Datei <code>Projekt1/src/A.java</code> anschauen. Die sieht n\u00e4mlich jetzt (wieder) so aus: </p> <pre><code>// Zeile 1 hinzugefuegt\n//\n</code></pre> <p>Wir f\u00fcgen nun das Gleiche in die <code>Projekt1/src/B.java</code> ein:</p> <pre><code>// Zeile 1 hinzugefuegt\n//\n</code></pre> <p>und committen diese \u00c4nderung:</p> <pre><code>git commit -am \"in B.java Zeile 1 hinzugefuegt\"\n</code></pre> <p>Die Commits lassen wir uns zun\u00e4chst mit <code>git log</code> anzeigen:</p> <pre><code>commit e754d18f0d8cb1e8593edca740fa75b84d5de30f (HEAD -&gt; tryB)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Sat Apr 3 09:56:28 2021 +0200\n\n    in B.java Zeile 1 hinzugefuegt\n\ncommit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 18:13:48 2021 +0200\n\n    in A.java Zeile 1 hinzugefuegt\n\ncommit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Fri Apr 2 08:42:37 2021 +0200\n\n    Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>Wir sehen, dass alle Commits aufgelistet werden, die bis zum aktuellen <code>HEAD</code> f\u00fchren. Es fehlt aber beispielsweise das Commit, das bereits f\u00fcr den master-Branch ausgef\u00fchrt wurde und in dem in <code>Projekt1/src/A.java</code> bereits <code>Zeile 2 hinzugefuegt</code> wurde. Um sich alle Commits auszugeben und sogar eine Graph-\u00e4hnliche Darstellung zu erhalten, verwenden wir </p> <pre><code>git log --all --graph\n</code></pre> <p>Wir erhalten folgende Ausgabe:</p> <pre><code>* commit e754d18f0d8cb1e8593edca740fa75b84d5de30f (HEAD -&gt; tryB)\n| Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| Date:   Sat Apr 3 09:56:28 2021 +0200\n| \n|     in B.java Zeile 1 hinzugefuegt\n|   \n| * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde (master)\n|/  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n|   Date:   Sat Apr 3 09:09:54 2021 +0200\n|   \n|       in A.java Zeile 2 hinzugefuegt\n| \n* commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd\n| Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| Date:   Fri Apr 2 18:13:48 2021 +0200\n| \n|     in A.java Zeile 1 hinzugefuegt\n| \n* commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\n  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n  Date:   Fri Apr 2 08:42:37 2021 +0200\n\n      Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>und daraus erkennt man, dass unser Repository (die Commit-Hostorie) derzeit so aussieht:</p> <p></p>"},{"location":"git/#git-merge-branches-zusammenfuhren","title":"git merge - Branches zusammenf\u00fchren","text":"<p>Wir haben folgende Situation:</p> <ul> <li>ausgehend von Commit <code>44ed3a8</code> (<code>in A.java Zeile 1 hinzugefuegt</code>) haben wir</li> <li>auf dem master-Branch weitergearbeitet und dort ein Commit <code>9c869b6</code> (<code>in A.java Zeile 2 hinzugefuegt</code>) erstellt und</li> <li>parallel dazu auf dem tryB-Branch gearbeitet und dort ein Commit <code>e754d18</code> (<code>in B.java Zeile 1 hinzugefuegt</code>) erstellt.</li> </ul> <p>Nun wollen wir beide Branches wieder zusammenf\u00fchren, um mit beiden \u00c4nderungen weiterzuarbeiten. Das Zusammenf\u00fchren von Branches erfolgt mithilfe von <code>git merge &lt;branchToMerge&gt;</code>. Wir wollen gerne den tryB-Branch in den master-Branch mergen, um dann mit dem master-Branch weiterzuarbeiten. Dazu wechseln wir zun\u00e4chst in den master-Branch. das erreichen wir, indem wir <code>checkout</code> verwenden:</p> <pre><code>git checkout master\n</code></pre> <p>Die Ausgabe ist</p> <pre><code>Zu Branch 'master' gewechselt\n</code></pre> <p>Nun mergen wir diesen mit dem <code>tryB</code>-Branch, indem wir <code>git merge tryB</code> eingeben. Wichtig ist, dass es sich hierbei auch um ein erzwungenes Commit (sogenanntes Merge-Commit) handelt, da beide Branches eigene Commits enthielten. Es wird uns eine Commit-nachricht angeboten. Mit <code>ZZ</code> verlassen wir den <code>vi</code>.</p> <p>Wenn wir uns nun die Commit-Logs ausgeben lassen (<code>git log --all --graph</code>), dann erhalten wir folgende Ausgabe </p> <pre><code>*   commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 (HEAD -&gt; master, tryB)\n|\\  Merge: e754d18 9c869b6\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 16:21:12 2021 +0200\n| | \n| |     Merge branch 'master' into tryB\n| | \n| * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 09:09:54 2021 +0200\n| | \n| |     in A.java Zeile 2 hinzugefuegt\n| | \n* | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f\n|/  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n|   Date:   Sat Apr 3 09:56:28 2021 +0200\n|   \n|       in B.java Zeile 1 hinzugefuegt\n| \n* commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd\n| Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| Date:   Fri Apr 2 18:13:48 2021 +0200\n| \n|     in A.java Zeile 1 hinzugefuegt\n| \n* commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\n  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n  Date:   Fri Apr 2 08:42:37 2021 +0200\n\n      Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>und erkennen, dass die beiden Branches nun wieder \"vereint\" sind:</p> <p></p> <p>Wenn wir uns <code>A.java</code> anschauen, dann sehen wir, dass diese Datei 2 Zeilen enth\u00e4lt und die Datei <code>B.java</code> eine. Beide sind also auf dem aktuellsten Stand. </p> <p>Wir \u00fcben Mergen an dieser Stelle nochmal und bilden 2 Branches, in dem einen erstellen wir uns eine \"Klasse\" <code>C.java</code> und in dem anderen eine <code>D.java</code>:</p> <pre><code>git branch classC\ngit branch classD\ngit checkout classC\ntouch Projekt1/src/C.java\necho \"// Zeile 1 hinzugefuegt\" &gt;&gt; Projekt1/src/C.java\ngit add Projekt1/src/C.java\ngit commit -m \"in C.java  Zeile 1 hinzugefuegt\"\ngit checkout classD\ntouch Projekt1/src/C.java\necho \"// Zeile 1 hinzugefuegt\" &gt;&gt; Projekt1/src/D.java\ngit add Projekt1/src/D.java\ngit commit -m \"in D.java  Zeile 1 hinzugefuegt\"\ngit checkout master\ngit merge classC\n</code></pre> <p>Hierbei handelt es sich um ein sogenanntes Fast-Forward-Commit, da der master-Branch keine eigenen \u00c4nderungen enthielt, sondern nur die \u00c4nderungen des classC-Branches in den master-Branch eingef\u00fcgt werden m\u00fcssen. Es gibt hier keine potenziellen Konflikte.</p> <p>Wenn wir nun aber auch den classD-Branch in den master-Branch mergen wollen, enth\u00e4lt sowohl der master-Branch \u00c4nderungen (<code>C.java</code>) als auch der classD-Branch (<code>D.java</code>). Hierbei handelt es sich also um ein Merge-Commit:</p> <pre><code>git merge classD\n</code></pre> <p><code>vi</code> \u00f6ffnet und wir k\u00f6nnen die Commit-Message \u00e4ndern oder sie so lassen. Wir beenden den <code>vi</code> wieder mit <code>ZZ</code>. <code>git log --all --graph</code> zeigt:</p> <pre><code>*   commit 15d5e0b00f2a4af5eaa4d84ba55e340f912ccb42 (HEAD -&gt; master)\n|\\  Merge: 0d86294 01f8dfd\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 17:12:18 2021 +0200\n| | \n| |     Merge branch 'classD'\n| | \n| * commit 01f8dfd9c68148c984db99dec980d227f1fe4044 (classD)\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 17:05:46 2021 +0200\n| | \n| |     in D.java Zeile 1 hinzugefuegt\n| | \n* | commit 0d8629458ca0a5e244c121be525f8e647b5c6bd9 (classC)\n|/  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n|   Date:   Sat Apr 3 16:51:14 2021 +0200\n|   \n|       in C.java Zeile 1 hinzugefuegt\n|   \n*   commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 (tryB)\n|\\  Merge: e754d18 9c869b6\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 16:21:12 2021 +0200\n| | \n| |     Merge branch 'master' into tryB\n| | \n| * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde\n| | Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| | Date:   Sat Apr 3 09:09:54 2021 +0200\n| | \n| |     in A.java Zeile 2 hinzugefuegt\n| | \n* | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f\n|/  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n|   Date:   Sat Apr 3 09:56:28 2021 +0200\n|   \n|       in B.java Zeile 1 hinzugefuegt\n| \n* commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd\n| Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n| Date:   Fri Apr 2 18:13:48 2021 +0200\n| \n|     in A.java Zeile 1 hinzugefuegt\n| \n* commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6\n  Author: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\n  Date:   Fri Apr 2 08:42:37 2021 +0200\n\n      Initiales Commit. A.java und B.java jeweils leer.\n</code></pre> <p>Die Commit-Historie unseres Repositories sieht so aus:</p> <p></p> <p>Eine umfangreiche Beschreibung aller \u00c4nderungen in den jeweiligen Commits erhalten Sie auch durch den Befehl <code>git show --pretty=fuller --abbrev-commit</code>. </p>"},{"location":"git/#konflikte-auflosen","title":"Konflikte aufl\u00f6sen","text":"<p>Gerade bei der Arbeit im Team kann es passieren, dass in verschiedenen Branches an der gleichen Datei \u00c4nderungen durchgef\u00fchrt werden. Wenn diese Branches dann \"gemerged\" werden sollen, kann Git diesen Konflikt nicht alleine aufl\u00f6sen (soll \u00c4nderung A gelten oder \u00c4nderung B oder beide?). Die Aufl\u00f6sung eines solchen Konfliktes muss durch die Entwicklerinnen geschehen. </p> <p>Zur Demonstration erzeugen wir uns erneut zwei Branches, <code>changeA1</code> und <code>changeA2</code> und f\u00fchren in beiden Branches eine \u00c4nderung an <code>Projekt1/src/A.java</code> durch:</p> <pre><code>git branch changeA1\ngit branch changeA2\n\ngit checkout changeA1\necho \"// eine \u00c4nderung durch Entwicklerin A\" &gt;&gt; Projekt1/src/A.java\ngit commit -am \"in A eine \u00c4nderung durch Entwicklerin A\"\n\ngit checkout changeA2\necho \"// eine \u00c4nderung durch Entwicklerin B\" &gt;&gt; Projekt1/src/A.java\ngit commit -am \"in A eine \u00c4nderung durch Entwicklerin B\"\n</code></pre> <p>Wenn wir jetzt versuchen, die beiden Branches mit <code>git merge changeA1</code> zu mergen, dann erhalten wir folgende Ausgabe:</p> <pre><code>automatischer Merge von Projekt1/src/A.java\nKONFLIKT (Inhalt): Merge-Konflikt in Projekt1/src/A.java\nAutomatischer Merge fehlgeschlagen; beheben Sie die Konflikte und committen Sie dann das Ergebnis.\n</code></pre> <p>Git kann diesen Konflikt nicht automatisch aufl\u00f6sen. Die Ausgabe von <code>git status</code> hilft dabei nicht wirklich weiter:</p> <pre><code>Auf Branch changeA2\nSie haben nicht zusammengef\u00fchrte Pfade.\n  (beheben Sie die Konflikte und f\u00fchren Sie \"git commit\" aus)\n  (benutzen Sie \"git merge --abort\", um den Merge abzubrechen)\n\nNicht zusammengef\u00fchrte Pfade:\n  (benutzen Sie \"git add/rm &lt;Datei&gt;...\", um die Aufl\u00f6sung zu markieren)\n    von beiden ge\u00e4ndert:    Projekt1/src/A.java\n\nkeine \u00c4nderungen zum Commit vorgemerkt (benutzen Sie \"git add\" und/oder \"git commit -a\")\n</code></pre> <p>Mit <code>git log --merge</code> k\u00f6nnen wir uns die Commits anschauen, die die \u00c4nderungen enthalten, welche f\u00fcr den Konflikt sorgen:</p> <pre><code>commit da1f715199e68f17ea276b07a9c3a6e88b319e8a (HEAD -&gt; changeA2)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Sun Apr 4 08:08:13 2021 +0200\n\n    in A eine \u00c4nderung durch Entwicklerin B\n\ncommit 63a9a40ab267bc53f2a688a45e6813d7c15170c6 (changeA1)\nAuthor: J. Freiheit &lt;freiheit@htw-berlin.de&gt;\nDate:   Sun Apr 4 08:07:25 2021 +0200\n\n    in A eine \u00c4nderung durch Entwicklerin A\n</code></pre> <p>Der Befehl <code>git diff</code> zeigt uns den Konflikt ganz konkret an:</p> <pre><code>diff --cc Projekt1/src/A.java\nindex a5c84c3,a920d29..0000000\n--- a/Projekt1/src/A.java\n+++ b/Projekt1/src/A.java\n@@@ -1,4 -1,4 +1,8 @@@\n  // Zeile 1 hinzugefuegt\n  // Zeile 2 hinzugefuegt\n  //\n++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n +// eine \u00c4nderung durch Entwicklerin B\n++=======\n+ // eine \u00c4nderung durch Entwicklerin A\n++&gt;&gt;&gt;&gt;&gt;&gt;&gt; changeA1\n</code></pre> <p>Diese Darstellung in der Datei finden wir auch wieder, wenn wir uns die Datei <code>Projekt1/src/A.java</code> anschauen:</p> <pre><code>// Zeile 1 hinzugefuegt\n// Zeile 2 hinzugefuegt\n//\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n// eine \u00c4nderung durch Entwicklerin B\n=======\n// eine \u00c4nderung durch Entwicklerin A\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; changeA1\n</code></pre> <p>In unserer Konflikt-Datei gibt es folgende drei Eintr\u00e4ge:</p> <ul> <li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code></li> <li><code>=======</code></li> <li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; changeA1</code> </li> </ul> <p>Aller Inhalt zwischen den ersten beiden Zeilen enth\u00e4lt die \u00c4nderungen des aktuellen Branches und alle \u00c4nderungen zwischen den letzten beiden Zeilen enth\u00e4lt alle \u00c4nderungen des Branches, in den gemerged werden soll (<code>changeA1</code>). Entwicklungsumgebungen (IntelliJ, Eclipse, Atom, Visual Studio Code usw.) unterst\u00fctzen bei der Aufl\u00f6sung solcher Konflikte. Wir \u00fcbernehmen einfach beide \u00c4nderungen h\u00e4ndisch und committen diese \u00c4nderung. <code>Projekt1/src/A.java</code> sieht also jetzt so aus:</p> <pre><code>// Zeile 1 hinzugefuegt\n// Zeile 2 hinzugefuegt\n//\n// eine \u00c4nderung durch Entwicklerin B\n// eine \u00c4nderung durch Entwicklerin A\n</code></pre> <p>und der Commit:</p> <pre><code>git commit -am \"Merge-Konflikt in A.java geloest. Aenderungen A UND B eingefuegt\".\n</code></pre>"},{"location":"git/#merge-abbrechen","title":"Merge abbrechen","text":"<p>Sollten Sie aufgrund der Konfliktmeldung den Merge-Vorgang doch nicht durchf\u00fchren wollen, k\u00f6nnen Sie mit </p> <pre><code>git merge --abort\n</code></pre> <p>den Merge abbrechen und mit </p> <pre><code>git reset\n</code></pre> <p>die in Konflikt stehenden Dateien auf einen als funktionierend bekannten Zustand zur\u00fcckzusetzen. </p>"},{"location":"git/#git-stash-arbeit-unterbrechen","title":"git stash - Arbeit unterbrechen","text":"<p>Angenommen, Sie haben bereits \u00c4nderungen durchgef\u00fchrt, diese sind aber noch nicht \"fertig\" und Sie wollen Sie deshalb noch nicht committen. Stattdessen m\u00fcssen Sie aber an anderer Stelle zun\u00e4chst noch einen BugFix erledigen. Dann k\u00f6nnen Sie Ihre gegenw\u00e4rtigen \u00c4nderungen \"stashen\" - in einen Stash-Modus setzen, also erstmal verstauen, um daran sp\u00e4ter weiterzuarbeiten:</p> <pre><code>git stash\n</code></pre> <p>Jetzt k\u00f6nnen Sie erstmal andere \u00c4nderungen durchf\u00fchren und committen und um dann wieder zu Ihren urspr\u00fcnglichen \u00c4nderungen zur\u00fcckzukehren, holen Sie diese wieder aus dem Stash-Modus:</p> <pre><code>git stash pop\n</code></pre>"},{"location":"git/#einige-weitere-nutzliche-befehle","title":"Einige weitere n\u00fctzliche Befehle","text":"<p>Angenommen, Sie haben committed, aber einige \u00c4nderungen vergessen (entweder vorher nicht geadded oder noch gar nicht ge\u00e4ndert), dann k\u00f6nnen Sie den vorherigen Commit \"\u00fcberschreiben\".</p> <pre><code>git commit -m \"zu frueh committed\"\n// jetzt noch die Aenderungen hinzufuegen\ngit commit --amend\n</code></pre> <p>Angenommen, Sie haben seit dem letzten Commit \u00c4nderungen an Dateien vorgenommen, die Sie aber gerne verwerfen m\u00f6chten. Sie werden in der Literatur daf\u00fcr Befehle finden, wie z.B. <code>git checkout HEAD</code> oder <code>git reset --hard</code>. Sie sollten damit \u00e4u\u00dferst vorsichtig sein! Bei <code>git checkout HEAD</code> (aslo dem \"Zur\u00fccksetzen\" auf das letzte Commit) bleiben die ge\u00e4nderten Dateien \"modifiziert\". Das hilft also gar nicht wirklich. <code>git reset --hard</code> kann Sie unter Umst\u00e4nden auf ein Commit zur\u00fccksetzen, das noch weiter zur\u00fcck in der Historie liegt, als Sie planen. Verwenden Sie zum Zur\u00fccksetzen Ihrer \u00c4nderungen (Undo) besser </p> <pre><code>git restore &lt;dateiUndo&gt;\n</code></pre> <p>Geben Sie also die Datei an, die Sie ge\u00e4ndert haben und die wieder auf den Zustand des letzten Commits zur\u00fcckgesetzt werden soll. </p> <p>L\u00f6schen Sie niemals einfach Dateien oder Ordner in dem durch Git verwalteten Ordner (Ihrem Repository) \u00fcber den Finder oder den Dateiexplorer! Die Idee von Git ist die, dass immer nur etwas hinzukommt. Selbst, wenn Sie eine bestimmte Datei nicht mehr ben\u00f6tigen, so kann es ja doch sein, dass diese in fr\u00fcheren Versionen vorkommt. Lassen Sie sie einfach im Verzeichnis!</p>"},{"location":"git/#aliases","title":"Aliases","text":"<p>Es ist ganz hilfreich, sich f\u00fcr einige Optionen Aliase zu definieren, da diese oft verwendet werden. Dazu nutzen Sie <code>git config</code>. Hier einige Beispiele von n\u00fctzlichen Aliases (aus dem Git-Buch):</p> <pre><code>git config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.st status\n</code></pre>"},{"location":"git/#git-als-kollaborationswerkzeug","title":"Git als Kollaborationswerkzeug","text":"<p>Im vorherigen Abschnitt haben wir diskutiert, wie wir Git zur Versionsverwaltung verwenden k\u00f6nnen. Dazu haben wir ein lokales Git-Repository angelegt. Nun wollen wir betrachten, wie Git als Kollaborationswerkzeug eingesetzt werden kann, d.h. wie mehere Entwicklerinnen zusammen an einem (globalen) Git-Repository arbeiten k\u00f6nnen. Dazu ben\u00f6tigen wir einen Host (Bereitsteller netzbasierter Dienste), der ein zentrales Git-Repository zur Verf\u00fcgung stellen kann. Es gibt mehrere solcher Git-Hosts. Die bekanntesten sind: </p> <ul> <li>GitHub</li> <li>GitLab</li> <li>Bibucket </li> </ul> <p>Wir zeigen das Verwenden eines zentralen Repositories exemplarisch f\u00fcr <code>GitHub</code>. Sie m\u00fcssen sich in <code>GitHub</code> registrieren. Die Verwendung von <code>GitHub</code> ist kostenlos. Die Idee eines zentralen Repositorys ist die, dass daran mehrere lokale Repositories angebunden sein k\u00f6nnen:</p> <p></p> <p>\u00dcber das zentrale Repository werden alle lokalen Repositories synchronisiert, so dass alle Repositories \u00fcber den gleichen Stand, d.h. alle Dateien und Ordner sowie die gleiche Commit-Historie verf\u00fcgen. Wichtig ist jedoch, dass man zum Entwickeln nicht permanent online sein muss. Vielmehr kann man beliebig lange offline auf dem eigenen lokalen Repository arbeiten, bis man irgendwann seine \u00c4nderungen in das zentrale Repository schreiben (push) bzw. dort abgelegte \u00c4nderungen aus anderen lokalen Repositories lesen (pull) m\u00f6chte.</p>"},{"location":"git/#ein-zentrales-repository-anlegen","title":"Ein zentrales Repository anlegen","text":"<p>Sie loggen sich in <code>GitHub</code> (oder dem von Ihnen gew\u00e4hlten Diensteanbieter) ein und klicken auf \"New\":</p> <p></p> <p>Dann geben Sie einen sprechenden Namen f\u00fcr das Repository ein. Sie k\u00f6nnen w\u00e4hlen, ob das Repository <code>Public</code> (f\u00fcr alle lesbar) oder <code>Private</code> (nur f\u00fcr Eingeladene lesbar) sein soll. Die darunter stehenden Checkboxen sollten Sie nicht anklicken, da Sie ein bereits existierendes lokales Repository mit diesem zentralen Repository verbinden wollen. In Ihrem lokalen Repository haben Sie ja wahrscheinlich bereits eine <code>.gitignore</code>-Datei. W\u00fcrden Sie diese Checkboxen markieren, m\u00fcssten Sie bereits ganz am Anfang mergen. Klicken Sie auf den Button <code>Create repository</code>. </p> <p></p> <p>Das zentrale Repository ist nun erstellt. Nun m\u00fcssen wir nur noch vorgehen, wie auf der Seite angegeben:</p> <p></p> <p>Im Terminal f\u00fchren wir im <code>workspace</code>-Ordner (in unserem lokalen Repository - der Ordner, der den <code>.git</code>-Ordner enth\u00e4lt) den Befehl </p> <pre><code>git remote add origin https://github.com/jfreiheit/einfuehrung-git.git\n</code></pre> <p>aus. <code>https://github.com/jfreiheit/einfuehrung-git.git</code> entspricht dabei der sogenannten Remote-URL  und lautet bei Ihnen nat\u00fcrlich anders. Es ist der Pfad (die URL) zu Ihrem zentralen Git-Repository. Mit diesem Befehl verbinden wir unser lokales Git-Repository mit dem zentralen Git-Repository. Wir geben dem zentralen Git-Repository dabei den Namen <code>origin</code>.</p> <p>Den n\u00e4chsten von <code>GitHub</code> vorgeschlagenen Befehl</p> <pre><code>git branch -M main\n</code></pre> <p>k\u00f6nnen wir ebenfalls ausf\u00fchren. Wir wissen bereits, dass wir damit einen neuen Branch erstellen, n\u00e4mlich <code>main</code>. Wir verlassen also den master-Branch und wechseln zu einem neuen main-Branch. Das kann man machen, muss man aber nicht. Die Option <code>-M</code> steht f\u00fcr <code>--move --force</code>. Damit bestimmen wir, dass wir einen <code>main</code>-Branch erstellen, selbst wenn dieser bereits existierte. Siehe auch die Dokumentation f\u00fcr git branch.</p> <p>Der dritte von <code>GitHub</code> vorgeschlagene Befehl </p> <pre><code>git push -u origin main\n</code></pre> <p>bewirkt, dass unser komplettes lokales Git-Repository auf das zentrale Git-Repository gespielt wird. Das hei\u00dft, der aktuelle Branch <code>main</code> wird auf das zentrale Git-Repository <code>origin</code> gepushed. Nach Ausf\u00fchrung dieses Befehls ist das zentrale Repository auf dem selben Stand wie das lokale Repository. </p>"},{"location":"git/#alltag-mit-git","title":"Alltag mit Git","text":"<p>Ihr lokales Repository ist nun mit dem zentralen Repository verkn\u00fcpft. Wenn Sie jetzt \u00c4nderungen an Ihrem Code (Ihrem lokalen Repository) durchf\u00fchren und diese \u00c4nderungen auf dem zentralen Repository speichern wollen, sieht Ihr \"Alltag\" wie folgt aus. </p>"},{"location":"git/#git-add-eine-neue-datei-hinzufugen","title":"git add - eine neue Datei hinzuf\u00fcgen","text":"<p>Angenommen, Sie erstellen eine neue Klasse (Datei), z.B. <code>Projekt1/src/E.java</code>, dann f\u00fcgen Sie diese neue Datei mit <code>git add &lt;neueDatei&gt;</code> Ihrem lokalen Repository hinzu:</p> <pre><code>git add Projekt1/src/E.java\n</code></pre> <p>Wenn Sie sich dann mit <code>git status</code> den Status des Repositorys anschauen, erhalten Sie</p> <pre><code>Auf Branch main\nIhr Branch ist auf demselben Stand wie 'origin/main'.\n\nZum Commit vorgemerkte \u00c4nderungen:\n  (benutzen Sie \"git restore --staged &lt;Datei&gt;...\" zum Entfernen aus der Staging-Area)\n    neue Datei:     Projekt1/src/E.java\n</code></pre> <p>Neue Dateien f\u00fcgen Sie mittels <code>git add &lt;neueDatei&gt;</code> dem Repository hinzu. </p>"},{"location":"git/#git-commit-anderungen-speichern","title":"git commit - \u00c4nderungen \"speichern\"","text":"<p>Angenommen, Sie haben \u00c4nderungen an Dateien hinzugef\u00fcgt, diese Dateien sind aber bereits Teil des Repositorys (wurden also bereits bei Erstellung mit <code>git add</code> hinzugef\u00fcgt). Dann speichern Sie diese \u00c4nderungen mit <code>git commit -am \"Commit-Message\"</code>. Angenommen, wir haben in <code>Projekt1/src/E.java</code> 2 Zeilen hinzugef\u00fcgt, dann committen wir diese \u00c4nderungen z.B. mit </p> <pre><code>git commit -am \"in E.java 2 Zeilen hinzugefuegt\"\n</code></pre> <p>Die Option <code>-m</code> steht daf\u00fcr, dass wir gleich die Commit-Message mit angeben. Fehlt diese Option, \u00f6ffnet sich ein <code>vi</code> und wir f\u00fcgen die Commit-Message nachtr\u00e4glich hinzu. Den <code>vi</code> verlassen wir mit <code>ZZ</code>. </p> <p>Die Option <code>-a</code> steht f\u00fcr <code>add</code>. Jede \u00c4nderung muss zun\u00e4chst hinzugef\u00fcgt werden. H\u00e4ufig sieht man daf\u00fcr die Verwendung des Befehls <code>git add .</code>. Das l\u00e4sst sich aber mit der Option <code>-a</code> auch beim Commit selbst erledigen. </p> <p>Wenn Sie sich dann mit <code>git status</code> den Status des Repositorys anschauen, erhalten Sie</p> <pre><code>Auf Branch main\nIhr Branch ist 1 Commit vor 'origin/main'.\n  (benutzen Sie \"git push\", um lokale Commits zu publizieren)\n\nnichts zu committen, Arbeitsverzeichnis unver\u00e4ndert\n</code></pre> <p>\u00c4nderungen am Code (Repository) \"committen\" (speichern) Sie mittels <code>git commit -am \"Commit-Message\"</code>. </p>"},{"location":"git/#git-push-anderungen-auf-das-zentrale-repository-spielen","title":"git push - \u00c4nderungen auf das zentrale Repository spielen","text":"<p>Sie k\u00f6nnen beliebig lange und oft Ihr lokales Repository \u00e4ndern, wie im Abschnitt Git als Versionierungswerkzeug beschrieben. Wenn Sie Ihr lokales Repository auf Ihr zentrales Repository spielen m\u00f6chten, verwenden Sie den Befehl <code>git push</code>. Damit stellen Sie das zentrale Repository auf den Stand Ihres lokalen Repositorys. </p> <pre><code>git push\n</code></pre> <p>ergibt folgende Ausgabe:</p> <pre><code>Objekte aufz\u00e4hlen: 8, fertig.\nZ\u00e4hle Objekte: 100% (8/8), fertig.\nDelta-Kompression verwendet bis zu 8 Threads.\nKomprimiere Objekte: 100% (3/3), fertig.\nSchreibe Objekte: 100% (5/5), 439 Bytes | 439.00 KiB/s, fertig.\nGesamt 5 (Delta 1), Wiederverwendet 0 (Delta 0), Pack wiederverwendet 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/jfreiheit/einfuehrung-git.git\n   15d5e0b..6ddd0dc  main -&gt; main\n</code></pre> <p>Damit \u00fcbernimmt das zentrale Repository den Stand des lokalen Repositorys. </p> <p>Um das zentrale Repository auf den Stand Ihres lokalen Repositorys zu bringen, verwenden Sie <code>git push</code>.</p> <p>Das hei\u00dft, wenn Sie alleine an Ihrem zenztralen Repository arbeiten, m\u00fcssen sie sich nur folgende Befehle merken:</p> <ol> <li><code>git add &lt;datei&gt;</code>  // falls die Datei neu erstellt wurde und Ihrem Repository bekannt gemacht (hinzugef\u00fcgt) werden soll</li> <li><code>git commit -am \"Commit-Message\"</code> // um die \u00c4nderungen ins lokale Repository zu \"speichern\"</li> <li><code>git push</code>  // um das zentrale Repository auf den Stand des lokalen Repositorys zu bringen</li> </ol> <p>So sieht einfach sieht der Alltag aus, wenn Sie alleine am (zentralen) Repository arbeiten. </p>"},{"location":"git/#ein-existierendes-zentrales-repository-verwenden","title":"Ein existierendes zentrales Repository verwenden","text":"<p>Angenommen, jemand anderer besitzt ein zentrales Repository und m\u00f6chte den Code mit Ihnen teilen - angenommen, ich m\u00f6chte mit Ihnen den Code aus meinem Repository <code>https://github.com/jfreiheit/einfuehrung-git.git</code> teilen. Sie k\u00f6nnen dieses Repository klonen (kopieren), indem sie einmalig </p> <pre><code>git clone https://github.com/jfreiheit/einfuehrung-git.git\n</code></pre> <p>eingeben. Dadurch erstellen Sie sich ein lokales Repository, das einer identischen Kopie (einem Clone) des zentralen Repositorys <code>https://github.com/jfreiheit/einfuehrung-git.git</code> entspricht. Dieses lokale Repository ist dann bereits auch mit dem zentralen Repository verbunden. </p> <p>Angenommen, ich f\u00fchre nun \u00c4nderungen an diesem zentralen Repository durch und somit einige Commits. Damit diese \u00c4nderungen auch Ihrem lokalen Repository bekannt werden, f\u00fchren Sie</p> <pre><code>git pull\n</code></pre> <p>aus. Damit \"holen\" Sie sich den aktuellen Stand des zentralen Repositories. </p>"},{"location":"git/#git-config","title":"git config","text":"<p>Sollten Sie aufgefordert werden, einige Accountdetails in Ihrer Git-Konfiguration zu speichern, dann machen Sie das. Sie k\u00f6nnen diese Schritte selbst dann vornehmen, wenn Sie nicht dazu aufgefordert werden:</p> <pre><code>git config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\n</code></pre> <p>In den Strings geben Sie nat\u00fcrlich Ihre Daten an. Weitere Informationen zur Konfiguration von Git finden Sie auch hier.</p>"},{"location":"git/#nutzliche-links-zu-git","title":"N\u00fctzliche Links zu Git","text":"<ul> <li>Git Dokumentation</li> <li>Git Buch</li> <li>Lerne Git mit Bitbucket Cloud</li> <li>Git-Tutorial: Git und die wichtigsten Befehle kennenlernen</li> <li>Learn Git Branching</li> <li>Git - Der einfache Einstieg</li> <li>Git in Bildern</li> <li>Visualizing Git Concepts</li> <li>Git Kata</li> <li>noch mehr Git Katas</li> </ul>"},{"location":"git/#egit-git-mit-eclipse","title":"EGit - Git mit Eclipse","text":"<p>Mit EGit integrieren Sie Git in Eclipse. Sie k\u00f6nnen pr\u00fcfen, ob Sie EGit bereits in Eclipse installiert haben, indem Sie in Eclipse unter <code>Help</code>\u2192<code>Eclipse Marketplace</code> den Reiter <code>Installed</code> anklicken und schauen, ob <code>EGit</code> in dieser Liste auftaucht. Wenn nicht, w\u00e4hlen Sie den Reiter <code>Search</code> und geben in die Suchleiste <code>EGit</code> ein und installieren das PlugIn. Sie k\u00f6nnen auch unter <code>Help</code>\u2192<code>Install new Software...</code> diese URL eintragen, um EGit zu installieren: http://download.eclipse.org/egit/updates. </p> <p>Sie finden die Installationsanleitung auch unter https://www.eclipse.org/egit/ oder z.B. auch hier und hier.</p> <p>Beim Verbinden Ihres lokalen Repositories mit Eclipse k\u00f6nnen Sie z.B. vorgehen wie hier beschrieben oder hier. </p>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen. F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort <code>class</code>, sondern <code>interface</code> verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort <code>extends</code>, sondern das Schl\u00fcsselwort <code>implements</code> verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse beliebig viele Interfaces implementieren. </p> <p>Interfaces sind automatisch <code>abstract</code>, d.h. das Schl\u00fcsselwort <code>abstract</code> muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. </p> \u00a0Abtrakte Klasse \u00a0Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort <code>extends</code>) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort <code>implements</code>), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort <code>abstract</code> deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort <code>interface</code> deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen <code>final</code> Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten (<code>static final</code>) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen <code>private</code>, <code>protected</code>, default und <code>public</code> sein in Interfaces sind alle Eigenschaften <code>public</code> Bsp.: <code>public abstract class Shape{ public abstract void draw(); }</code> Bsp.: <code>public interface Drawable{ void draw(); }</code>"},{"location":"interfaces/#das-interface-comparable","title":"Das Interface <code>Comparable</code>","text":"<p>Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem <code>java.lang</code>-Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode <code>compareTo()</code>. Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> wird verwendet, um zu vergleichen, ob <code>this</code> gr\u00f6\u00dfer, kleiner oder gleich <code>obj</code> ist. Das bedeutet, dass wir <code>compareTo()</code> in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. </p> <p>Die Methode <code>this.compareTo(Object obj)</code> gibt ein <code>int</code> zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll:</p> <ul> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert positiv (<code>&gt; 0</code>), dann ist <code>this</code> gr\u00f6\u00dfer als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert negativ (<code>&lt; 0</code>), dann ist <code>this</code> kleiner als <code>obj</code>,</li> <li>ist der zur\u00fcckgegebene <code>int</code>-Wert <code>0</code>, dann ist <code>this</code> gleich <code>obj</code>.</li> </ul> <p>Angenommen, wir wollen f\u00fcr die folgende Klasse <code>Rectangle</code> (aus dem Abschnitt Abstrakte Klassen) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch <code>Shape</code> aus Abstrakte Klassen):</p> <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n}\n</code></pre> <p>Die Klasse <code>Rectangle</code> erbt also von der abstrakten Klasse <code>Shape</code> und muss deshalb die Methoden <code>perimeter()</code> und <code>area()</code> implementieren. Nun geben wir an, dass <code>Rectangle</code> auch das Interface <code>Comparable</code> implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um <code>implements Comparable</code>, d.h. die Klassendeklaration sieht jetzt so aus:</p> <pre><code>public class Rectangle extends Shape implements Comparable {}\n</code></pre> <p>Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: <code>The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object)</code>. Es werden zwei <code>QuickFixes</code> angeboten, </p> <ul> <li>entweder <code>Add unimplemented methods</code> </li> <li>oder <code>Make type Rectangle abstract</code>. </li> </ul> <p>Letzteres wollen wir aber nicht (<code>Rectangle</code> soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir <code>Add unimplemented methods</code>. Eclipse f\u00fcgt uns die <code>compareTo()</code>-Methode in den Code ein:</p> <pre><code>public class Rectangle extends Shape implements Comparable\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung:</p> <pre><code>Comparable is a raw type. References to generic type Comparable&lt;T&gt; should be parameterized\n</code></pre> <p>Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface <code>Comparable</code> typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse <code>Rectangle</code>. Wir typisieren deshalb <code>Comparable</code> mit <code>Rectangle</code>: </p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler:</p> <pre><code>The type Rectangle must implement the inherited abstract method Comparable&lt;Rectangle&gt;.compareTo(Rectangle)\n</code></pre> <p>Dadurch, dass wir <code>Comparable</code> mit <code>Rectangle</code> typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode </p> <pre><code>    @Override\n    public int compareTo(Object o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n</code></pre> <p>implementieren, sondern die Methode </p> <pre><code>    @Override\n    public int compareTo(Rectangle o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n</code></pre> <p>Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei <code>equals(Object o)</code>, pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein <code>Rectangle</code> handelt. Wir \u00e4ndern also den Parametertyp in <code>compareTo()</code>:</p> <pre><code>public class Rectangle extends Shape implements Comparable&lt;Rectangle&gt;\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Rectangle o) {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n}\n</code></pre> <p>In Zukunft typisieren wir das <code>Comparable</code>-Interface noch, bevor wir <code>Add unimplemented methods</code> w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. </p> <p>F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein <code>Rectangle</code>-Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da <code>compareTo()</code> ein <code>int</code> zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von <code>height</code> und <code>width</code> verwenden:</p> <pre><code>    @Override\n    public int compareTo(Rectangle o) {\n        int diff = (this.height+this.width) - (o.height+o.width);\n        return diff;\n    }\n</code></pre> <p>Wenn die Summe von <code>height</code> und <code>width</code> von <code>this</code> gr\u00f6\u00dfer ist, als von <code>o</code>, dann geben wir eine positive <code>int</code>-Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative <code>int</code>-Zahl und wenn sie gleich sind, dann <code>0</code>. Damit entsprechen wir den Vorgaben von <code>compareTo()</code>. </p>"},{"location":"interfaces/#laufzeittypen-eines-rectangle-objektes","title":"Laufzeittypen eines <code>Rectangle</code>-Objektes","text":"<p>Ein <code>Rectangle</code>-Objekt ist nicht nur vom Laufzeittyp <code>Rectangle</code>, sondern auch</p> <ul> <li>von Laufzeittyp <code>Shape</code>, wegen <code>public class Rectangle extends Shape</code>, </li> <li>vom Laufzeittyp <code>Comparable</code>, wegen <code>public class Rectangle implements Comparable</code> und</li> <li>vom Laufzeittyp <code>Object</code>, weil das immer so ist, weil jede Klasse implizit von <code>Object</code> erbt. </li> </ul> <p>Wir k\u00f6nnten nun also in jeder beliebigen Klasse eine Sortiermethode haben, z.B.: </p> <pre><code>    public static void sortieren(Comparable[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo(unsorted[index+1]) &gt; 0) \n                {\n                    Comparable tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n</code></pre> <p>Die Methode implementiert Bubble-Sort. In Zeile <code>7</code> verwenden wir die <code>compareTo()</code>-Methode. Das geht genau deshalb, weil klar ist, dass ein Objekt, das (auch) vom Typ <code>Comparable</code> ist, diese Methode auf jeden Fall als Eigenschaft besitzt. Wenn wir nun in der Klasse, in der die Methode <code>sortieren()</code> implementiert ist, folgende <code>main()</code>-Methode haben:</p> <pre><code>public static void main(String[] args) {\n        Rectangle[] rectArr = new Rectangle[6];\n        rectArr[0] = new Rectangle(9, 13);\n        rectArr[1] = new Rectangle(4, 17);\n        rectArr[2] = new Rectangle(12, 5);\n        rectArr[3] = new Rectangle(8, 9);\n        rectArr[4] = new Rectangle(10, 11);\n        rectArr[5] = new Rectangle(5, 15);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(rectArr);\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n    }\n</code></pre> <p>dann erhalten wir folgende Ausgabe:</p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] \n[  4 x 17 =  68,00 ] \n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[ 10 x 11 = 110,00 ] \n[  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[  5 x 15 =  75,00 ] \n[  4 x 17 =  68,00 ] \n[ 10 x 11 = 110,00 ] \n[  9 x 13 = 117,00 ] \n</code></pre> <p>f\u00fcr den Fall, dass wir in unserer Klasse <code>Rectangle</code> auch die <code>toString()</code>-Methode wie folgt implementiert haben:</p> <pre><code>    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n</code></pre> <p>Success</p> <p>Wir haben f\u00fcr unsere Klasse <code>Rectangle</code> das Interface <code>Comparable</code> implementiert. Das bedeutet, dass wir in <code>Rectangle</code> die Methode <code>compareTo()</code> so implementiert haben, dass <code>Rectangle</code>-Objekte der Gr\u00f6\u00dfe nach sortiert werden k\u00f6nnen. Wir haben also eine Ordnung \u00fcber <code>Rectangle</code>-Objekte definiert. Nach \"au\u00dfen\" ist sichtbar, dass wir eine solche Ordnung implementiert haben, dass <code>Rectangle</code>-Objekte also sortierbar sind, weil sie (auch) vom Typ <code>Comparable</code> sind. F\u00fcr alle Objekte, die in Java existieren, wissen wir, dass sie sortierbar sind, sobald sie auch vom Typ <code>Comparable</code> sind. <code>Comparable</code> stellt also eine Schnittstelle zur Sortierbarkeit dar. Wenn wir eine eigene Klasse schreiben und wir eine Ordnung \u00fcber die Objekte dieser Klasse definieren k\u00f6nnen, sollten wir das Interface <code>Comparable</code> implementieren, denn dadurch geben wir nach \"au\u00dfen\" an, dass sich die Objekte der Klasse sortieren (ordnen) lassen.</p>"},{"location":"interfaces/#zwischenfazit","title":"Zwischenfazit","text":"<p>Wir haben nun schon mehrere Methoden kennengelernt, die wir f\u00fcr eigene Klassen implementieren sollten.</p> <ul> <li>Die <code>toString()</code>-Methode erben wir von <code>Objects</code>. Wir sollten <code>toString()</code> f\u00fcr \"unsere\" Klassen \u00fcberschreiben, damit wir eine textuelle Repr\u00e4sentation unserer Objekte haben. <code>toString()</code>wird implizit angewendet, sobald eine <code>String</code>-Repr\u00e4sentation erforderlich ist, z.B. ist <code>System.out.println(refVariable);</code>das Gleiche wie <code>System.out.println(refVariable.toString());</code>. </li> <li>Die <code>equals()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>equals()</code> f\u00fcr \"unsere\" Klassen implementieren, um zu definieren, wann Objekte \"unserer\" Klasse gleich sind. Hierbei ist wichtig, zu beachten, dass <code>refVar1 == refVar2</code> ein reiner Referenzvergleich ist, der nichts dar\u00fcber aussagt, ob die Objekte gleich  sind, sondern nur ein <code>true</code> ergibt, wenn beide Variablen auf dasselbe Objekt zeigen. Die Gleichheit von Objekten wird mittels <code>equals()</code>-Methode definiert. </li> <li>Die <code>hashCode()</code>-Methode erben wir ebenfalls von <code>Objects</code>. Wir sollten <code>hashCode()</code>genau dann implementieren, wenn wir <code>equals()</code> implementieren. Wichtig ist, dass zwei Objekte den gleichen Hash-Code haben (<code>hashCode()</code> liefert den gleichen <code>int</code>-Wert zur\u00fcck), wenn die beiden Objekte laut <code>equals()</code> gleich sind. Gut ist dar\u00fcber hinaus (aber nicht Bedingung), dass zwei Objekte einen unterschiedlichen Hash-Code haben, wenn sie laut <code>equals()</code>-Methode nicht gleich sind (<code>equals()</code>liefert <code>false</code> zur\u00fcck). Der Hash-Code wird bei Hash-basierten Datentypen, wie z.B. Collections verwendet, um diese einzusortieren. </li> <li>Die Methode <code>compareTo()</code> muss implementiert werden, wenn wir das Interface <code>Comparable</code> implementieren. Mithilfe von <code>compareTo()</code> legen wir eine Ordnung \u00fcber die Objekte der Klasse fest, d.h. wir geben an, wann ein Objekt gr\u00f6\u00dfer/kleiner/gleich einem anderen Objekt der gleichen Klasse ist. Dadurch, dass wir das <code>Comparable</code>-Interface implementieren, zeigen wir nach \"au\u00dfen\", dass die Objekte unserer Klasse sortierbar  sind. </li> </ul>"},{"location":"interfaces/#eine-bessere-implementierung","title":"Eine bessere Implementierung","text":"<p>Wir haben bereits bei der Implementierung der Klasse <code>Rectangle</code> gesehen, dass wir das Interface <code>Comparable</code> bei der Implementierung von <code>Rectangle</code> typisieren sollten. Das w\u00e4re f\u00fcr eine wirklich korrekte Implementierung der Methode <code>sortieren()</code> ebenfalls angebracht. Dann w\u00fcrden wir in dieser Methode <code>Comparable</code> mit <code>Rectangle</code> typisieren:</p> <pre><code>    public static void sortieren(Comparable&lt;Rectangle&gt;[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo((Rectangle) unsorted[index+1]) &gt; 0) \n                {\n                    Comparable&lt;Rectangle&gt; tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n</code></pre> <p>Wenn wir also den Typ <code>Comparable</code> verwenden, dann erg\u00e4nzen wir ihn um die Typisierung <code>&lt;Rectangle&gt;</code> (Zeilen <code>1</code> und <code>9</code>). Das f\u00fchrt allerdings dazu, dass wir dann auch in Zeile <code>7</code> den Typ von <code>unsorted[index+1]</code> nach <code>Rectangle</code> konvertieren m\u00fcssen (<code>(Rectangle) unsorted[index+1]</code>). Damit verlieren wir aber unsere allgemeine Anwendbarkeit der Methode <code>sortieren()</code> f\u00fcr alle Klassen, die <code>Comparable</code> implementiert haben. Insbesondere w\u00fcrde die Methode dann nicht mehr f\u00fcr z.B. die Klasse <code>Circle</code> anwendbar sein: </p> <pre><code>public class Circle extends Shape implements Comparable&lt;Circle&gt;\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public int compareTo(Circle o) {\n        if(this.radius &gt; o.radius) return 1;\n        else if(this.radius &lt; o.radius) return -1;\n        else return 0; // this.radius == o.radius\n    }\n\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Wenn wir nun versuchen w\u00fcrden, die <code>sortieren()</code>-Methode auf ein <code>Circle[]</code> anzuwenden, lie\u00dfe sich das Programm gar nicht compilieren:</p> <pre><code>    public static void main(String[] args) \n    {\n        Circle[] circArr = new Circle[6];\n        circArr[0] = new Circle(5.0);\n        circArr[1] = new Circle(5.5);\n        circArr[2] = new Circle(4.0);\n        circArr[3] = new Circle(2.5);\n        circArr[4] = new Circle(7.0);\n        circArr[5] = new Circle(1.0);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        // sortieren(circArr);      // Fehler\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n    }\n</code></pre> <p>Deshalb w\u00e4re es eine bessere Implementierung, wenn wir das Interface <code>Comparable</code> nicht in den konkreten Klassen <code>Rectangle</code> und <code>Circle</code> (und in jeder weiteren Klasse, die wir auf der Basis von <code>Shape</code> erstellen) implementieren, sondern gleich in der Abstrakten Klasse <code>Shape</code>:</p> <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\n    public abstract double perimeter();\n    public abstract double area();\n\n}\n</code></pre> <p>Da <code>Shape</code> eine abstrakte Klasse ist, muss die Methode <code>compareTo()</code> nicht in <code>Shape</code> implementiert werden. Diese Methode w\u00fcrde nun <code>abstract</code> an alle Klassen vererbt, die von <code>Shape</code> erben:</p> Rectangle.java <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public int compareTo(Shape o) \n    {\n        Rectangle r = (Rectangle)o;\n        int diff = (this.height+this.width) - (r.height+r.width);\n        return diff;\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n\n}\n</code></pre> Circle.java <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public int compareTo(Shape o) \n    {\n        Circle c = (Circle)o;\n        if(this.radius &gt; c.radius) return 1;\n        else if(this.radius &lt; c.radius) return -1;\n        else return 0;  // this.radius == c.radius\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Beachten Sie, dass die Klassen <code>Rectangle</code> und <code>Circle</code> jetzt nur noch von <code>Shape</code> erben, aber nicht mehr das Interface <code>Comparable</code> implementieren (jeweils Zeile <code>1</code>). Es darf nicht mehrmals von einer Klasse implementiert werden und <code>Shape</code> implementiert es ja bereits. </p> <p>Da <code>Shape</code> diese Interface aber implementiert, wird die Methode <code>compareTo()</code> als abstrakte Methode an die Klassen <code>Rectangle</code> und <code>Circle</code> vererbt. Die Methode muss also von diesen Klassen implementiert werden. Nun wird sie aber mit dem Parametertyp <code>Shape</code> vererbt (Zeile <code>24</code> in <code>Rectangle.java</code> bzw. <code>23</code> in <code>Circle.java</code>). Dieser Parameter muss deshalb zun\u00e4chst innerhalb der Methode <code>compareTo()</code> konvertiert werden (Zeile <code>25</code> in <code>Circle.java</code> bzw. <code>26</code> in <code>Rectangle.java</code>). </p> <p>Die allgemeine Anwendung der Methode <code>sortieren()</code> in der Testklasse gelingt nun aber:</p> TestklasseShape.java <pre><code>public class TestklasseShape \n{\n\n    public static void sortieren(Comparable&lt;Shape&gt;[] unsorted)\n    {   \n        for(int bubble=1; bubble&lt;unsorted.length; bubble++)\n        {\n            for(int index=0; index&lt;unsorted.length-bubble; index++)\n            {\n                if(unsorted[index].compareTo((Shape) unsorted[index+1]) &gt; 0) \n                {\n                    Comparable&lt;Shape&gt; tmp = unsorted[index];\n                    unsorted[index] = unsorted[index+1];\n                    unsorted[index+1] = tmp;            \n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        Rectangle[] rectArr = new Rectangle[6];\n        rectArr[0] = new Rectangle(9, 13);\n        rectArr[1] = new Rectangle(4, 17);\n        rectArr[2] = new Rectangle(12, 5);\n        rectArr[3] = new Rectangle(8, 9);\n        rectArr[4] = new Rectangle(10, 11);\n        rectArr[5] = new Rectangle(5, 15);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(rectArr);\n        for(Rectangle r : rectArr)\n        {\n            System.out.println(r.toString());\n        }\n\n        Circle[] circArr = new Circle[6];\n        circArr[0] = new Circle(5.0);\n        circArr[1] = new Circle(5.5);\n        circArr[2] = new Circle(4.0);\n        circArr[3] = new Circle(2.5);\n        circArr[4] = new Circle(7.0);\n        circArr[5] = new Circle(1.0);\n        System.out.printf(\"%n%n------------------------ unsortiert --------------------------%n%n\");\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n        System.out.printf(\"%n%n------------------------- sortiert ---------------------------%n%n\");\n        sortieren(circArr);\n        for(Circle c : circArr)\n        {\n            System.out.println(c.toString());\n        }\n    }\n}\n</code></pre> <p>Wir k\u00f6nnen nun alle Objekte sortieren lassen, die auf der Klasse <code>Shape</code> basieren. </p> <pre><code>------------------------ unsortiert --------------------------\n\n[  9 x 13 = 117,00 ] \n[  4 x 17 =  68,00 ] \n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[ 10 x 11 = 110,00 ] \n[  5 x 15 =  75,00 ] \n\n\n------------------------- sortiert ---------------------------\n\n[ 12 x  5 =  60,00 ] \n[  8 x  9 =  72,00 ] \n[  5 x 15 =  75,00 ] \n[  4 x 17 =  68,00 ] \n[ 10 x 11 = 110,00 ] \n[  9 x 13 = 117,00 ] \n\n\n------------------------ unsortiert --------------------------\n\n(radius: 5,00 -&gt; area:  78,54 ] \n(radius: 5,50 -&gt; area:  95,03 ] \n(radius: 4,00 -&gt; area:  50,27 ] \n(radius: 2,50 -&gt; area:  19,63 ] \n(radius: 7,00 -&gt; area: 153,94 ] \n(radius: 1,00 -&gt; area:   3,14 ] \n\n\n------------------------- sortiert ---------------------------\n\n(radius: 1,00 -&gt; area:   3,14 ] \n(radius: 2,50 -&gt; area:  19,63 ] \n(radius: 4,00 -&gt; area:  50,27 ] \n(radius: 5,00 -&gt; area:  78,54 ] \n(radius: 5,50 -&gt; area:  95,03 ] \n(radius: 7,00 -&gt; area: 153,94 ] \n</code></pre>"},{"location":"interfaces/#eine-noch-bessere-implementierung","title":"Eine noch bessere Implementierung","text":"<p>Obwohl wir nun in <code>Shape</code> das Interface <code>Comparable</code> implementieren, geben wir die Verantwortung der Implementierung der Methode <code>compareTo()</code> an die konkreten Klassen <code>Rectangle</code> und <code>Circle</code> weiter. Es stellt sich die Frage, ob sich die <code>compareTo()</code>-Methode nicht bereits in <code>Shape</code> implementieren lie\u00dfe. Die Antwort auf diese Frage sollte ja lauten, denn ansonsten sollten wir das Interface gar nicht bereits durch die abstrakte Klasse <code>Shape</code> implementieren lassen. Wir haben in <code>Shape</code> gen\u00fcgend Informationen, um die <code>compareTo()</code>-Methode zu implementieren. Wir k\u00f6nnen daf\u00fcr entweder <code>perimeter()</code> oder <code>area()</code> verwenden. Wir entscheiden uns f\u00fcr die Verwendung von <code>area()</code>:</p> Shape.java <pre><code>public abstract class Shape implements Comparable&lt;Shape&gt;\n{\n\n    public abstract double perimeter();\n    public abstract double area();\n\n    @Override\n    public int compareTo(Shape o) \n    {   \n        return (this.area() - o.area());\n    }\n\n}\n</code></pre> <p>In abstrakten Klassen m\u00fcssen nicht, im Gegensatz zu Interfaces, alle Methoden abstrakt sein. Es k\u00f6nnen auch Methoden bereits implementiert werden. Diese Methoden m\u00fcssen dann nicht mehr in den Klassen implementiert werden, die von der abstrakten Klasse erben. Die Klassen <code>Rectangle</code> und <code>Circle</code> ben\u00f6tigen also keine eigene Implementierung der <code>compareTo()</code>-Methode mehr:</p> Rectangle.java <pre><code>public class Rectangle extends Shape\n{\n    private int width, height;\n\n    public Rectangle(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double perimeter() \n    {   \n        return (2.0 * (this.width + this.height));\n    }\n\n    @Override\n    public double area() \n    {\n        return (this.width * this.height);\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"[ %2d x %2d = %6.2f ] \", this.width, this.height, this.area()); \n        return s;\n    }\n\n}\n</code></pre> Circle.java <pre><code>public class Circle extends Shape\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    @Override\n    public double perimeter() \n    {\n        return Math.PI * 2.0 * this.radius;\n    }\n\n    @Override\n    public double area() \n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    @Override\n    public String toString()\n    {   String s = String.format(\"(radius: %.2f -&gt; area: %.2f ] \", this.radius, this.area()); \n        return s;\n    }\n\n}\n</code></pre> <p>Wir haben ausgenutzt, dass in der Klasse <code>Shape</code> bereits gen\u00fcgend Informationen vorliegen, um die Methode <code>compareTo()</code> korrekt f\u00fcr alle Klassen zu implementieren, die von <code>Shape</code> erben. Diese Methode muss dann von diesen konkreten Klassen nicht mehr implementiert werden. Wir vermeiden so doppelten Code. Die <code>testklasseShape</code> bleibt unver\u00e4ndert f\u00fcr alle abgeleiteten Klassen aus <code>Shape</code> anwendbar. </p>"},{"location":"maps/","title":"Maps","text":"<p>Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel (keys) enth\u00e4lt und die rechte Spalte die Werte (values). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine <code>Set</code>. </p> <p>Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map. F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial.</p>"},{"location":"maps/#statt-add-und-addall-hier-put-und-putall","title":"Statt <code>add()</code> und <code>addAll()</code> hier <code>put()</code> und <code>putAll()</code>","text":"<p>Da nicht das <code>Collections</code>-Interface f\u00fcr <code>Maps</code> implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer <code>Map</code> leider auch nicht \u00fcber <code>add()</code> bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber <code>addAll()</code>, sondern \u00fcber </p> <ul> <li><code>put(K key, V value)</code> und</li> <li><code>putAll(Map m)</code>.</li> </ul> <p><code>K</code> ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und <code>V</code> ein Platzhalter f\u00fcr den Typ der Werte. </p>"},{"location":"maps/#typ-einer-map-und-typ-eines-schlussel-werte-paares","title":"Typ einer <code>Map</code> und Typ eines Schl\u00fcssel-Werte-Paares","text":"<p>Eine <code>Map</code> wird also mit zwei Typen typisiert:</p> <ul> <li><code>Map&lt;K, V&gt;</code></li> </ul> <p>wobei <code>K</code> den Typ der Schl\u00fcssel und <code>V</code> den Typ der Werte definiert. </p> <p>Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist</p> <ul> <li><code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. <code>Entry</code> ist eine innere Klasse in der Klasse <code>Map</code> (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer <code>Map</code> ist <code>Map&lt;K,V&gt;</code> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser <code>Map</code> ist <code>Map.Entry&lt;K,V&gt;</code>. </p>"},{"location":"maps/#statt-iterator-hier-entryset","title":"Statt <code>iterator()</code> hier <code>entrySet()</code>","text":"<p>Die Objektmethode <code>iterator()</code> gibt es f\u00fcr <code>Map</code> leider auch nicht. Stattdessen wird hier die Methode <code>entrySet()</code> verwendet. Da es sich bei einer <code>Map</code> um eine <code>Set</code> von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ <code>Map.Entry&lt;K,V&gt;</code>) handelt, liefert <code>entrySet()</code> eine </p> <ul> <li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul> <p>zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine <code>Set</code>. Diese ist typisiert und zwar mit dem Typ <code>Map.Entry</code>, welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. <code>Map.Entry</code> ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel <code>K</code> und dem Typ der Werte <code>V</code>. F\u00fcr <code>K</code> und <code>V</code> werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter. </p>"},{"location":"maps/#klassenbaum-fur-map","title":"Klassenbaum f\u00fcr <code>Map</code>","text":"<p>Der Klassenbaum f\u00fcr <code>Map</code> hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr <code>Collection</code>. Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder.</p> <p></p> <p>Auch hier ist es wieder so, dass wir <code>Map</code> als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen <code>EnumMap</code>, <code>HashMap</code> und <code>TreeMap</code> verwenden. Die am h\u00e4ufigsten verwendete Klasse ist <code>HashMap</code>, da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird <code>TreeMap</code> verwendet. </p>"},{"location":"maps/#erstes-beispiel","title":"Erstes Beispiel","text":"<p>Wir betrachten ein erstes Beispiel. Wir erstellen eine <code>HashMap</code> und f\u00fcgen vier Eintr\u00e4ge hinzu:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class Maps {\n\n    public static void main(String[] args) \n    {\n        Map&lt;String,Double&gt; m = new HashMap&lt;&gt;();\n        m.put(\"s0512345\", 1.7);     // neues Schluessel-Werte-Paar hinzugefuegt\n        m.put(\"s0587654\", 2.3);     // neues Schluessel-Werte-Paar hinzugefuegt\n        m.put(\"s0512345\", 2.7);     // Schluessel existiert bereits --&gt; Wert geaendert\n        m.put(\"s0555555\", 3.0);     // neues Schluessel-Werte-Paar hinzugefuegt\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>8</code> wird unsere <code>Map</code> erzeugt. Die Referenzvariable auf die <code>Map</code> hei\u00dft <code>m</code>. Die Schl\u00fcssel sind vom Typ <code>String</code> und die Werte sind vom Typ <code>Double</code>. Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse <code>HashMap</code> erzeugt. </li> <li>In Zeile <code>9</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0512345\"</code>, der Wert (value) ist <code>1.7</code>. Beachten Sie, dass hier ein Auto-Boxing des <code>double</code>-Wertes <code>1.7</code> in ein <code>Double</code> stattfindet. </li> <li>In Zeile <code>10</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0587654\"</code>, der Wert (value) ist <code>2.3</code> (erneut Auto-Boxing). </li> <li>In Zeile <code>11</code> wird erneut die <code>put()</code>-Methode aufgerufen. Der Schl\u00fcssel <code>\"s0512345\"</code> existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert <code>1.7</code> wird nun <code>2.7</code>. Die <code>Map</code> enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. </li> <li>In Zeile <code>12</code> f\u00fcgen wir mithilfe der <code>put()</code>-Methode ein weiteres Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel (key) ist <code>\"s0555555\"</code>, der Wert (value) ist <code>3.0</code> (erneut Auto-Boxing). </li> </ul> <p>Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung):</p> <p></p> <p>Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten:</p> <p></p> <p>Die Anwendung dieser Methoden auf unsere Map <code>m</code> zeigen die folgenden Anweisungen:</p> <pre><code>Set&lt;String&gt; keys = m.keySet();                  // Menge aller Schluessel\nCollection&lt;Double&gt; values = m.values();         // Collection aller Werte\nSet&lt;Map.Entry&lt;String, Double&gt;&gt; entries = m.entrySet();  // Menge aller Schluessel-Werte-Paare\n</code></pre> <ul> <li>die Objektmethode <code>keySet()</code> liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;K&gt;</code>,</li> <li>die Objektmethode <code>values()</code> liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist <code>Collection&lt;V&gt;</code>,</li> <li>die Objektmethode <code>entrySet()</code> liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></li> </ul>"},{"location":"maps/#durch-eine-map-laufen","title":"Durch eine <code>Map</code> laufen","text":"<p>Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode <code>entrySet()</code> verwenden. F\u00fcr den R\u00fcckgabetyp <code>Map.Entry&lt;K,V&gt;</code> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung:</p> <ul> <li><code>getKey()</code> liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>K</code>,</li> <li><code>getValue()</code> liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist <code>V</code>.</li> </ul> <p>Wir betrachten f\u00fcr unsere Map <code>m</code> ein Beispiel: </p> <p><pre><code>for(Map.Entry&lt;String, Double&gt; eintrag : m.entrySet())\n{\n    System.out.println( eintrag.getKey() + \"\u00a0 :\u00a0 \" + eintrag.getValue());\n}\n</code></pre> - In Zeile <code>1</code> wird die Methode <code>m.entrySet()</code> aufgerufen, diese gibt eine <code>Set&lt;Map.Entry&lt;String, Double&gt;&gt;</code> zur\u00fcck. Jeder einzelne Eintrag in dieser <code>Set</code> ist also vom Typ <code>Map.Entry&lt;String,Double&gt;</code>. Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable <code>eintrag</code>. Wir nutzen hier also erneut die for-each-Schleife, um durch eine <code>Set</code> zu laufen.  - In Zeile <code>3</code> verwenden wir die Objektmethoden <code>getKey()</code> und <code>getValue()</code>, die uns von <code>Map.Entry</code> zur Verf\u00fcgung gestellt werden. <code>getKey()</code> gibt uns hier einen <code>String</code> zur\u00fcck (den Schl\u00fcssel) und <code>getValue()</code> gibt hier ein <code>Double</code> zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von <code>Double</code> nach <code>String</code> (impliziter Aufruf von <code>toString()</code> f\u00fcr <code>Double</code>). </p> <p>Es erfolgt folgende Ausgabe:</p> <pre><code>s0512345\u00a0 :\u00a0 2.7\ns0555555\u00a0 :\u00a0 3.0\ns0587654\u00a0 :\u00a0 2.3\n</code></pre> <p>Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. </p> <p>Wir probieren auch noch die Objektmethoden <code>keySet()</code> und <code>value()</code> aus, die f\u00fcr eine <code>Map</code> zur Verf\u00fcgung stehen:</p> <pre><code>for(String schluessel : m.keySet())\n{\n    System.out.println(\"key : \" + schluessel);\n}\n</code></pre> <p>erzeugt: </p> <pre><code>key : s0512345\nkey : s0555555\nkey : s0587654\n</code></pre> <p>und </p> <pre><code>for(Double wert : m.values())\n{\n    System.out.println(\"value : \" + wert.toString());  // toString() wuerde auch implizit aufgerufen\n}\n</code></pre> <p>erzeugt: </p> <pre><code>value : 2.7\nvalue : 3.0\nvalue : 2.3\n</code></pre> <p>\u00dcbung</p> <p>Was wird ausgegeben? <pre><code>Map&lt;String, String&gt; accounts = new HashMap&lt;&gt;();\n\naccounts.put(\"anton\", \"anton@email.de\");\naccounts.put(\"berta\", \"berta@email.de\");\naccounts.put(\"caesar\", \"caesar@email.de\");\naccounts.put(\"anton\", \"antonius@email.de\");\n\n// Iteration ueber alle Eintraege (Map.Entry) der Map\nfor(Map.Entry&lt;String, String&gt; entry : accounts.entrySet()) \n{\n    System.out.println(\"Account : \" + entry.getKey() + \" E-Mail : \" + entry.getValue());\n}\n</code></pre></p>"},{"location":"maps/#zusammenfassung-maps","title":"Zusammenfassung Maps","text":"<ul> <li>Maps speichern Referenztypen als Schl\u00fcssel und Werte</li> <li>Maps werden typisiert mit <code>K</code> (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und <code>V</code> (Platzhalter f\u00fcr den Referenztyp des Wertes) </li> <li>Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt)</li> <li>der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection</li> <li>der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist <code>Map.Entry&lt;K,V&gt;</code></li> </ul> <p>Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine <code>Map</code>. Weitere Methoden finden Sie hier.</p> Objektmethode  Beschreibung  <code>V get(K key)</code> Gibt den Wert zum Schl\u00fcssel <code>key</code> zur\u00fcck. Ist der Schl\u00fcssel <code>key</code> nicht in der <code>Map</code> enthalten, wird <code>null</code> zur\u00fcckgegeben. <code>V put(K key, V value)</code> F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel <code>key</code> und dem Wert <code>value</code> in die <code>Map</code> ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel <code>key</code> bereits existiert, wird der <code>value</code> \u00fcberschrieben. <code>void putAll(Map m) F\u00fcgt alle Element der Map <code>m</code> in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben. <code>void clear()</code> Entfernt alle Elemente aus der Map. <code>boolean containsKey(Object k)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel <code>k</code> in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt <code>k</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean containsValue(Object v)</code> Gibt <code>true</code> zur\u00fcck, wenn es einen Eintrag mit dem Wert <code>v</code> in der Map gibt. Der Vergleich der Werte mit dem Objekt <code>v</code> erfolgt mit der <code>equals()</code>-Methode. <code>boolean isEmpty()</code> Gibt <code>true</code> zur\u00fcck, wenn sich keine Elemente in der Map befinden. <code>V remove(Object key)</code> Entfernt den Eintrag mit dem Schl\u00fcssel <code>key</code> aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn <code>key</code> in der Map enthalten ist, sonst <code>null</code>). <code>int size()</code> Gibt die Anzahl der Elemente in der Map zur\u00fcck. <code>Set keySet() Gibt eine <code>Set</code> mit allen Schl\u00fcsseln der Map zur\u00fcck. <code>Collection values() Gibt eine <code>Collection</code> mit allen Werten der Map zur\u00fcck. <code>Set&gt; entrySet() Gibt eine <code>Set</code> mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als <code>Map.Entry der Map zur\u00fcck."},{"location":"uebungen/","title":"\u00dcbungen","text":""},{"location":"uebungen/#ubung-1-codereview-und-static","title":"\u00dcbung 1 (Codereview und static)","text":"Was ist an diesem Code alles falsch? <pre><code>package uebungen.uebung1;\n\n/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\n    private double celsius;\n    private double fahrenheit;\n\n    public Konvertierung(double celsius) \n    {       \n        this.celsius = celsius;\n        this.fahrenheit = celsius * 1.8 + 32;       \n    }\n\n    public Konvertierung(double fahrenheit) \n    {       \n        this.celsius = fahrenheit - 32 * 5/9;\n        this.fahrenheit = fahrenheit;       \n    }\n\n    public void print()\n    {\n        System.out.println(this.celsius + \"\\u00B0C = \" + this.fahrenheit + \"\\u00B0F\");\n    }\n}\n</code></pre> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 <p>```java package uebungen.uebung1;</p> <pre><code>/*\n * \u00b0C = (\u00b0F - 32) * 5/9 (von Fahrenheit in Celsius)\n * \u00b0F = \u00b0C * 1,8 + 32 (von Celsius nach Fahrenheit)\n */\n\npublic class Konvertierung {\n\n    private Konvertierung() {\n\n    }\n\n    public static double celsiusToFahrenheit(double celsius) {\n        final double FACTOR_CELSIUS_TO_FAHRENHEIT = 1.8;\n        final int DIFFERENCE_CELSIUS_TO_FAHRENHEIT = 32;\n\n        double fahrenheit = celsius * FACTOR_CELSIUS_TO_FAHRENHEIT \n                + DIFFERENCE_CELSIUS_TO_FAHRENHEIT;\n\n        return fahrenheit;\n    }\n\n    public static double fahrenheitToCelsius(double fahrenheit) {\n        final double FACTOR_FAHRENHEIT_TO_CELSIUS = 5.0/9.0;\n        final int DIFFERENCE_FAHRENHEIT_TO_CELSIUS = 32;\n\n        double celsius = (fahrenheit - DIFFERENCE_FAHRENHEIT_TO_CELSIUS) * FACTOR_FAHRENHEIT_TO_CELSIUS;\n\n        return celsius;\n    }\n}\n```\n</code></pre>"},{"location":"wiederholung/","title":"Wiederholung","text":""},{"location":"wiederholung/#datentypen","title":"Datentypen","text":""},{"location":"wiederholung/#wertetypen","title":"Wertetypen","text":"<ul> <li>es wird der konkrete Wert in der Variablen gespeichert\u000b</li> <li>belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche</li> </ul> Beispiele Wertetypen <pre><code>    // boolean f\u00fcr Wahrheitswerte true und false\n    boolean x = false;          // mit false initialisiert\n    boolean wahr = true;        // Schluesselwort true\n    boolean falsch = !wahr;     // Enthaelt den Wert false\n\n    // byte, short, int, long f\u00fcr ganze Zahlen\n    byte a = 0;         // mit 0 initialisiert\n    short b = 124;      // Zuweisung einer ganzen Zahl\n    int c = a + b;      // Wertebereich immer beachten!\n    long lo = c * 200;  // l nicht als Variablenname verwenden\n\n    // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen!\n    char zeichen = 'c';     // Doppelte \" f\u00fcr Strings!\u00a0\n\n    // float und double f\u00fcr Flie\u00dfkommazahlen\n    float f = 0.0f;         // Wird mit 0.0 initialisiert\n    double d = 100.25;      // Dezimalpunkt statt Dezimalkomma!!\n ```\n\n### Referenztypen\n\n- es wird eine Referenz auf ein Objekt gespeichert\u000b\n- Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand)\n- Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator\n\n=== \"Beispiele Referenztypen\"\n```java\n    // Schluesselwort class um neue Klasse (Typ) zu definieren\n    public class Power\n    {\n    int base; // Objektvariablen, f\u00fcr jedes Objekt\n    int exp;  // existieren Kopien im Arbeitsspeicher\n\n            public Power(int base, int exp)\n            {\n                this.base = base;\n                this.exp = exp;\n            }\n\n            // Objektmethode\n            public void print()\n            {\n                System.out.println(this.base + \"^\" + this.exp);\n            }\n        }\n\n        // irgendwo im Hauptprogramm\n        public static void main(String[] args)\u00a0\n        {\n            Power p1 = new Power(2,4);\n            Power p2 = new Power(2,4);\n            p1.print();\n            p2.print();\n            boolean equal = (p1 == p2);     // true oder false ?\n        }\n</code></pre>"},{"location":"wiederholung/#datenstrukturen","title":"Datenstrukturen","text":""},{"location":"wiederholung/#variablen","title":"Variablen","text":"<ul> <li>einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein)</li> <li>sind von einem Datentyp (Wertetyp oder Referenztyp)</li> <li>haben einen Namen</li> <li>besitzen einen Wert<ul> <li>Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =)</li> <li>Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final)</li> </ul> </li> <li>besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope)<ul> <li>Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde</li> <li>lokale Variable: in einer Methode deklariert \u2192 dort lokal</li> <li>globale Variable: in einer Klasse deklariert \u2192 dort global</li> </ul> </li> </ul> Beispiele Variablen <pre><code>    int zahlen = 0;             // konventionelle Variable\n    final float PI = 3.14516f;  // Konstante\n\n    // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz\n    int[] zahlenFeld = new int[100];\n\n    // Klassen mit Objekt- und Klassenvariablen\n    public class Power \n    {\n        int base; // Objektvariablen, f\u00fcr jedes Objekt\n        int exp;  // existieren Kopien im Arbeitsspeicher\n\n        public Power(int base, int exp)\n        {\n            this.base = base;\n            this.exp = exp;\n        }\n\n        public String toString()\n        {\n            // lokale Variable --&gt; nur in der Methode gueltig\n            String output =\u00a0 this.base + \"^\" + this.exp;\n            return output;\n        }\n\n        // Variablen sollten mit einem Kleinbuchstaben beginnen\n        // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden\n    }\n</code></pre>"},{"location":"wiederholung/#arrays","title":"Arrays","text":"<ul> <li>Arrays sind Objekte (Referenztypen)</li> <li>speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein)</li> <li>besitzen Methoden (z.B. <code>sort()</code>) und Variablen (z.B. <code>length</code>)</li> <li>k\u00f6nnen auch mehrdimensional sein</li> <li>Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes</li> </ul> Beispiele Arrays <pre><code>    // Einfache Deklaration -&gt; nur Datentyp bekannt, keine Laenge\n    int[] zahlen;           // Eckige Klammern f\u00fcr Array-Datentyp\n\n    // Erzeugen eines neuen Feldes und Zuweisen der Referenz\n    zahlen = new int[100];  // new-Operator, hier: Angabe der Laenge\n\n    // Explizite Initialisierung bei der Deklaration\n    // Bei Initialisiert mit Werten --&gt; keine Laengenangabe noetig\n    float[] werte = new float[10];      // Platz f\u00fcr 10 Werte \n    double[] fib = { 1.0, 2.0, 3.0 };   // Werte in {}-Klammern\n\n    // Mehrdimensionale Felder\n    int[][] hdBild = new int[1920][1080];\n\n    // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden\n    Power[] potenzen = new Power[5];    // Noch keine Objekte enthalten\n    potenzen[0] = new Power(2, 4);      // Zuweisung Objekt an Index 0\n</code></pre>"},{"location":"wiederholung/#literale","title":"Literale","text":"<ul> <li>sind Werte</li> <li>sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein)</li> <li>keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen</li> <li>meistens<ul> <li>auf der rechten Seite einer Wertzuweisung</li> <li>als Parameterwert bei Aufruf einer Methode</li> <li>als Vergleichswert bei logischen Ausdr\u00fccken</li> </ul> </li> </ul> Beispiele Literale <pre><code>    100\n    true\n    'a'\n    \"hallo\"\n    {1,2,3,4}\n    5.5\n</code></pre>"},{"location":"wiederholung/#ausdrucke","title":"Ausdr\u00fccke","text":"<ul> <li>kleinste ausf\u00fchrbare Einheit eines Programms</li> <li> <p>z.B.:</p> <ul> <li>Zuweisung</li> <li>numerische Berechnung</li> <li>logische Bedingung</li> </ul> </li> <li> <p>Operatoren:</p> <ul> <li>arithmetisch:     <code>+, -, *, /, %, ++, --</code></li> <li>relational:       <code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code></li> <li>logisch:          <code>!, &amp;&amp;, ||</code></li> <li>Zuweisung:        <code>=, +=, -=, *=, /=, %=</code></li> <li>sonstige:         <code>a?b:c, typecast, new, instanceof, .</code></li> </ul> </li> </ul>"},{"location":"wiederholung/#anweisungen","title":"Anweisungen","text":"<ul> <li>Einzelanweisung       <code>;</code></li> <li>Block                 <code>{}</code></li> <li>Deklaration           <code>Typ Methode</code>, <code>Typ Variable</code></li> <li>Ausdruck</li> <li>Bedingung             <code>if() else  switch() case</code></li> <li>Schleifen             <code>for        while       do while</code></li> <li>Exceptions            <code>try catch()</code></li> <li>Assertions            <code>assert</code></li> </ul> Beispiele Anweisungen <pre><code>// Bloecke immer zwischen geschweiften Klammern\n{\n// Anweisung 1...\n// Anweisung 2...\n}\n\n    // Definition und Deklaration\n    int a;\n    float b = 1.0f;\n\n    // Einfacher Ausdruck\n    a = 1010;\u00a0\n\n    // Bedingungen\n    if (a == 1010)\u00a0         // if-Zweig muss immer vorhanden sein\n    {\n        // Anweisungen...\n    }\n    else if (a == 1011)\u00a0    // 0 - beliebig viele else-if-Zweige\n    {\n        // Anweisungen...\n    }\n    else\u00a0           // 0 - 1 else-Zweig\n    {\n        // Anweisungen...\n    }\n\n    switch (a)      // zu pruefende Variable in Klammern\n    {\n        case 1010: { b*=2.0; break; }   // beliebig viele case-Zweige\n        case 1011: { b*=3.0; break; }   // break nicht vergessen\n        default: { b=0.0f; }            // Zweig f\u00fcr alle anderen Werte\n    }\n\n    int[] meinFeld = {1,2,3,4,5};\n    // for-Schleife\n    // 1. Initialisierung\n    // 2. Schleifen-Bedingung\n    // 3. Anweisungen nach Schleifendurchlauf\n    // Schleifen-Anweisungen als Block hinter for\n    for (int index = 0; index &lt; meinFeld.length; index++) \n    {\n        System.out.println(meinFeld[index]);\n    }\n\n    // while-Schleife\n    // Nur Schleifen-Bedingung angeben\n    // Auf Endlos-Schleifen achten\n    while (index &lt; meinFeld.length) \n    {\u00a0\n        System.out.println(meinFeld[index]);\n        index++;\n    }\n</code></pre>"},{"location":"wiederholung/#methoden","title":"Methoden","text":"<ul> <li>wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden</li> <li>Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. <code>void</code>)</li> <li>Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden</li> <li>bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum <code>return</code>)</li> <li>werden Methoden mit R\u00fcckgabetyp (also nicht <code>void</code>) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert)</li> </ul> Methodenstack/Call stack <pre><code>public static int multiply(int a, int b) {\nreturn a*b;\n}\n\n    public static int square(int n) {\n        return multiply(n,n);\n    }\n\n    public static void printSquare(int n) {\n    int squared = square(n);\n    System.out.println(n + \" x \" + n + \" = \"\u00a0+ squared);\n    }\n\n    public static void main(String[] args) {\n        printSquare(4);\n    }\n</code></pre>"},{"location":"wiederholung/#vererbung","title":"Vererbung","text":"<ul> <li>Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse)</li> <li>Schl\u00fcsselwort <code>extends</code></li> <li>jede Klasse (bis auf <code>Object</code>) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch <code>Object</code></li> <li>Vererbung beschreibt \u201eis-a\u201c-Beziehung</li> <li>Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als <code>final</code> definiert wurden) \u2192 @Override verwenden</li> <li>Originalmethode kann mit Schl\u00fcsselwort <code>super</code> aufgerufen werden</li> </ul>"},{"location":"wiederholung/#konstruktoren","title":"Konstruktoren","text":"<ul> <li>besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden</li> <li>gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht <code>void</code>)</li> <li>wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren)</li> <li>Aufruf von <code>this</code> und <code>super</code> m\u00f6glich</li> <li>werden nicht vererbt</li> </ul> Beispiele Konstruktoren <pre><code>    public class Power {\n    int base;\n    int exp;\n\n        public Power()\n        {\n            this(1,0);  // Aufruf des Konstruktors in Zeile 15\n        }\n\n        public Power(int base)\n        {\n            this(base, 0);  // Aufruf des Konstruktors in Zeile 15\n        }\n\n        public Power(int base, int exp)\n        {\n            this.base=base;     // Parameterwerte f\u00fcr base und int\n            this.exp=exp;       // auf Objektvariablen sichern\n        }\n    }\n\n    public static void main(String[] args) {\n        Power p1 = new Power();         // p1.base = 1, p1.exp = 0\n        Power p2 = new Power(10);       // p2.base = 10, p2.exp = 0\n        Power p3 = new Power(10,5);     // p3.base = 10, p3.exp = 5\n    }\n</code></pre>"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","title":"Access Controller (Zugriffsmodifizierer)","text":"<ul> <li>Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung</li> <li> <p>Klassen</p> <ul> <li><code>public</code>      Zugriff von au\u00dferhalb des Paketes</li> <li>(default)     Zugriff nur innerhalb des Paketes</li> <li><code>final</code>       von der Klasse k\u00f6nnen keine Klassen erben</li> <li><code>abstract</code>    Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind)</li> </ul> </li> <li> <p>Variablen und Methoden (wenn Klasse <code>public</code>)</p> <ul> <li><code>public</code>      Zugriff von \u00fcberall (bei Variablen vermeiden!)</li> <li><code>protected</code>   Zugriff aus Klasse und Kindklasse</li> <li>(default)     Zugriff aus Klasse und Paket</li> <li><code>private</code>         Zugriff nur aus Klasse</li> </ul> </li> </ul>"},{"location":"wiederholung/#kleinigkeiten-die-wir-nicht-betrachtet-haben","title":"\"Kleinigkeiten\", die wir nicht betrachtet haben","text":""},{"location":"wiederholung/#das-schlusselwort-static","title":"Das Schl\u00fcsselwort <code>static</code>","text":"<p>Mit dem Schl\u00fcsselwort <code>static</code> beschreiben wir eine Eigenschaft der Klasse. Das Schl\u00fcsselwort <code>static</code> kann verwendet werden f\u00fcr</p> <ul> <li>Die Deklaration einer (Klassen-)Variablen. Eine Klassenvariable existiert f\u00fcr die Klasse genau ein Mal (alle Objekte der Klasse \"teilen\" sich diese eine Variable).</li> <li>Die Deklaration einer (Klassen-)Methode. Eine statische Methode (Klassenmethode) kann aufgerufen werden, ohne ein Objekt der Klasse zu erzeugen. Wir werden h\u00e4ufig statische Methoden in der Programmklasse (die Klasse mit der <code>main()</code>-Methode) erstellen, um diese in der <code>main()</code>-Methode aufzurufen, ohne vorher ein Objekt der Programmklasse erzeugen zu m\u00fcssen.</li> <li>Die Deklaration einer Klasse, wenn diese eine Klasse in einer anderen Klasse ist. Dazu kommen wir sp\u00e4ter.</li> </ul> <p>Der Zugriff auf eine statische Variable bzw. statische Methode erfolgt ebenfalls per Punktnotation, aber vor dem Punkt steht dann der Klassenname. H\u00e4ufig wird der Klassenname und der Punkt aber auch weggelassen.</p>"},{"location":"wiederholung/#die-for-each-schleife","title":"Die for-each-Schleife","text":"<p>Wir haben ein Array stets so durchlaufen, dass wir in einer <code>for</code>-Schleife jeden m\u00f6glichen Index f\u00fcr das Array erzeugt haben und dann \u00fcber den Index auf den Wert der einzelnen Elemente zugegriffen haben, also z.B.:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor (int index = 0; index &lt; args.length; index++) \n{\n    System.out.print(numbers[index]);\n}\n</code></pre> <p>Wenn wir alle Elemente eines Arrays lesen wollen, k\u00f6nnen wir das aber auch so machen:</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\n    System.out.print(number);\n}\n</code></pre> <p>Wir bezeichnen diese Schleifensyntax auch als for-each-Schleife. Die allgemeine Syntax ist</p> <pre><code>for(TypElement variablenNameElement : nameDesArrays)\n{\n    // hier lesende Verwendung von variablenNameElement\n}\n</code></pre> <p>Beachten Sie, dass Sie mit der for-each-Schleife nur lesenden Zugriff auf die Elemente des Arrays haben. Wenn Sie z.B. schreiben</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nfor(int number : numbers)\n{\n    number = 5;\n}\n</code></pre> <p>, dann \u00e4ndert das nichts an den Werten im Array! Beachten Sie aber auch, dass das Element ja auch eine Referenz auf ein Objekt sein k\u00f6nnte, dann verh\u00e4lt es sich nat\u00fcrlich anders, wenn Sie daf\u00fcr Objektmethoden aufrufen, die \u00c4nderungen am Objekt bewirken (Setter).</p>"},{"location":"wiederholung/#die-klasse-javautilarrays","title":"Die Klasse <code>java.util.Arrays</code>","text":"<p>Die Klasse <code>Arrays</code> aus dem <code>java.util</code>-Paket hat einige n\u00fctzliche Methoden f\u00fcr Arrays. Insbesondere interessant d\u00fcrfte die <code>toString()</code>-Methode sein. Wir werden diese Klasse manchmal verwenden, wenn wir uns z.B. keine eigenen <code>toString()</code>-Methoden f\u00fcr unsere Arrays schreiben wollen. Die Dokumentation der Klasse <code>Arrays</code> finden Sie z.B. hier. Beachten Sie, dass Sie zum Verwenden der Klasse das <code>java.util</code>-Paket importieren m\u00fcssen.</p> <pre><code>int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nSystem.out.println(Arrays.toString(numbers));\n</code></pre> <p>Weitere interessante Methoden dieser Klasse sind <code>copyOf()</code>, <code>binarySearch()</code> und <code>sort()</code>.</p> \u00dcbung <pre><code>Ist die `toString()`-Methode der `Arrays`-Klasse statisch oder handelt es sich um eine Objektmethode?\n</code></pre>"},{"location":"wrapper/","title":"Wrapper-Klassen","text":"<p>Motivation</p> <p>Letzte Woche haben wir mit folgender Fragestellung geendet: Wie wandeln wir einen <code>String</code> zu einem <code>int</code> (oder <code>double</code>) um? Die Antwort, die uns den Ausblick auf das Thema der heutigen Woche gibt, war: mit Wrapper-Klassen.</p> <p>In Programmierung I haben wir am Anfang die Datentypen <code>int</code>, <code>boolean</code>, <code>double</code>, <code>char</code>, <code>long</code> usw. kennengelernt. Wir haben diese Datentypen als Wertetypen kennenglernt, denn sie k\u00f6nnen nur Werte abbilden. Das Gegenst\u00fcck dazu sind Referenztypen, welche Referenzen auf Objekte repr\u00e4sentieren. F\u00fcr jeden Wertetyp gibt es aber auch einen entsprechenden Referenztyp, die sogenannten Wrapper-Klassen. Diese sind <code>Integer</code>, <code>Double</code>, <code>Float</code>, <code>Short</code>, <code>Byte</code>, <code>Long</code>, <code>Character</code> und <code>Boolean</code> und befinden sich im <code>java.lang</code>-Paket (also dem Standardpaket von Java - muss nicht importiert werden). Wir werden diese Wrapper-Klassen dieses Semester h\u00e4ufiger verwenden, insbesondere wenn wir Collections kennenlernen. </p> <p>Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" (wrappen) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel <code>int</code> \u2194 <code>Integer</code> verdeutlichen:</p> <p></p> <p>Der <code>int</code>-Wert <code>10</code> wird zu einem Typ <code>Integer</code> und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von Referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. </p> <p>Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von <code>boolean</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code> und <code>double</code> so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von <code>char</code> <code>Character</code> und die Wrapper-Klasse von <code>int</code> <code>Integer</code>. </p>  Wertetyp  Referenztyp (Wrapper-Klasse)  <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>boolean</code> <code>Boolean</code> <code>char</code> <code>Character</code>"},{"location":"wrapper/#objekterzeugung","title":"Objekterzeugung","text":"<p>Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen:</p> <ul> <li>Verwendung des Kontruktors, Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>Verwendung der statischen Methode <code>valueOf()</code>,  Parameterwert entweder vom Typ <code>String</code> oder vom entsprechenden Wertetyp,</li> <li>sogenanntes Boxing (automatisches wrappen eins Wertes in seinen Referenztyp).</li> </ul> <p>Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von <code>Integer</code> an. Es gilt aber f\u00fcr alle Wrapper-Klassen. </p>"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","title":"Verwendung des Kontruktors - deprecated","text":"<p>F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von <code>Integer</code> als ein <code>int</code>-Wert) oder es wird ein <code>String</code> \u00fcbergeben, der idealerweise einen passenden Wert ent\u00e4lt, also f\u00fcr <code>Integer</code> soll der <code>String</code> eine Zahl enthalten. Am Beispiel von <code>Integer</code> k\u00f6nnte das z.B. so aussehen:</p> <pre><code>// Konstruktor mit Uebergabe Wertetyp\nint i = 100;\nInteger iObject1 = new Integer(i);\nInteger iObject2 = new Integer(100);\n\n// Konstruktor mit Uebergabe String\nString s = \"100\";\nInteger iObject3 = new Integer(s);\nInteger iObject4 = new Integer(\"100\");\n\n// Moeglich f\u00fcr alle numerischen Datentypen und boolean\n</code></pre> <p>F\u00fcr <code>Character</code> gibt es nur einen parametrisierten Konstruktor: <code>Character\u200b(char value)</code>. Die \u00dcbergabe eines <code>Strings</code> ist dort nicht m\u00f6glich. </p> <p>Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated, sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden <code>valueOf()</code> zu verwenden. </p>"},{"location":"wrapper/#die-valueof-methoden","title":"Die <code>valueOf()</code>-Methoden","text":"<p>Die <code>valueOf()</code>-Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften:</p> <ol> <li>sie sind statisch, d.h. der Aufruf erfolgt \u00fcber <code>Klassenname.valueOf()</code>,</li> <li>sie sind sogenannte Erzeugermethoden, denn sie geben ein Objekt der Klasse zur\u00fcck</li> </ol> <p>Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein <code>String</code> \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele</p> <pre><code>// Wrapper-Klassen haben die Klassenmethoden\n// valueOf(Wertetyp b) ...\nInteger iObject1 = Integer.valueOf(100);\nBoolean bObject1 = Boolean.valueOf(true);\nDouble  dObject1 = Double.valueOf(5.5);\n\n// ... oder valueOf(String s)\nInteger iObject2 = Integer.valueOf(\"100\");\nBoolean bObject2 = Boolean.valueOf(\"true\");\nDouble  dObject2 = Double.valueOf(\"5.5\");\n</code></pre> <p>Auch hier gilt wieder, dass f\u00fcr <code>Character</code> nur eine <code>valueOf()</code>-Methode existiert, n\u00e4mlich <code>valueOf(char c)</code>. Die \u00dcbergabe eines <code>Strings</code> ist nicht m\u00f6glich. </p>"},{"location":"wrapper/#auto-boxing","title":"Auto-Boxing","text":"<p>Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing.  Beispiele:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n</code></pre> <p>Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter <code>Eclipse</code> \u2192 <code>Preferences</code> \u2192 <code>Java</code> \u2192 <code>Compiler</code> \u2192 <code>Errors/Warnings</code> folgende Einstellungen:</p> <p></p> <p>\u00dcbung</p> <p>Was wird ausgegeben und warum?  <pre><code>    Integer i1 = 5000;\n    Integer i2 = 5000;\n\n    System.out.println(i1 == i2);\n</code></pre></p>"},{"location":"wrapper/#werte-extrahieren","title":"Werte extrahieren","text":"<p>H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher <code>int</code>-Wert von einem <code>Integer</code>-Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethoden zur Verf\u00fcgung also: <code>intValue()</code>, <code>doubleValue()</code>, <code>charValue()</code>, <code>booleanValue()</code> usw. Betrachten wir nochmal die Beispiele von eben:</p> <pre><code>Integer   io1 = 100;\nBoolean   bo1 = true;\nCharacter co1 = 'a';\nDouble    do1 = 5.5;\nFloat     fo1 = 2.7f;\nLong      lo1 = 1234L;\n\nint     i1 = io1.intValue();        // 100\nboolean b1 = bo1.booleanValue();    // true\nchar    c1 = co1.charValue();       // 'a'\ndouble  d1 = do1.doubleValue();     // 5.5\nfloat   f1 = fo1.floatValue();      // 2.7\nlong    l1 = lo1.longValue();       // 1234\n</code></pre> <p>Aber auch hier gibt es wieder ein Auto-Unboxing. Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <code>&lt;wrapperTyp&gt;Value()</code>-Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben:</p> <pre><code>int     i2 = io1;   // 100\nboolean b2 = bo1;   // true\nchar    c2 = co1;   // 'a'\ndouble  d2 = do1;   // 5.5\nfloat   f2 = fo1;   // 2.7\nlong    l2 = lo1;   // 1234\n</code></pre> <p>Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. </p> <p>\u00dcbung</p> <p>Geht das und wenn ja, warum? Was wird jeweils ausgegeben? <pre><code>    Integer i1 = 5000;\n    Integer i2 = 5000;\n    Integer i3 = 5001;\n\n    System.out.println(i1 &gt;= i2);\n    System.out.println(i3 &gt; i2);\n</code></pre></p> <p>Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von <code>Double</code>. Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden <code>String</code> erzeugt werden kann, indem die statische <code>&lt;WrapperTyp&gt;.parse&lt;WrapperTyp&gt;</code>-Methode verwendet wird. </p> <p></p>"},{"location":"wrapper/#strings-in-wertetypen","title":"Strings in Wertetypen","text":"<p>Wir wissen jetzt schon, dass wir uns mithilfe der <code>valueOf(String s)</code>-Methode Objekte einer Wrapper-Klasse erzeugen k\u00f6nnen. Unter Verwendung von <code>intValue()</code> k\u00f6nnte man z.B. aus einem <code>Intger</code>-Objekt den <code>int</code>-Wert extrahieren. Das ginge auch mit Auto-Unboxing. F\u00fcr die Umwandlung von <code>String</code> nach <code>int</code> verwendet man aber am besten die <code>parseInt()</code>-Methode. </p> <pre><code>String eingabe = JOptionPane.showInputDialog(\"Geben Sie eine Zahl ein: \");\nint zahl = Integer.parseInt(eingabe);\n</code></pre> <p>F\u00fcr <code>double</code> steht uns daf\u00fcr <code>Double.parseDouble(String s)</code> zur Verf\u00fcgung usw. </p> <p>Success</p> <p>Jetzt haben wir unser Problem gel\u00f6st, wir k\u00f6nnen <code>String</code> in einen <code>int</code> umwandeln! Wir kennen nun Wrapper-Klassen und deren <code>parseXXX(String)</code>-Methoden.</p>"},{"location":"wrapper/#links-zu-den-java-docs","title":"Links zu den Java-Docs","text":"<p>Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. </p> <ul> <li>Boolean</li> <li>Byte</li> <li>Character</li> <li>Double</li> <li>Float</li> <li>Integer</li> <li>Long</li> <li>Short</li> </ul> <p>\u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number. Diese enth\u00e4lt die Objektmethoden <code>byteValue()</code>, <code>doubleValue()</code>, <code>floatValue()</code>, <code>intValue()</code>, <code>longValue()</code> und <code>shortValue()</code>. Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. </p> <p>\u00dcbung</p> <p>Diese \u00dcbung gibt ein Hinweis auf das folgende Thema: Schauen Sie sich einmal die Java-Dokumentation der Klasse <code>Integer</code> an. Welche Exception kann die <code>parseInt(String)</code>-Methode werfen? </p>"},{"location":"wrapper/#ausblick","title":"Ausblick","text":"<p>Wir wissen nun, wie wir einen <code>String</code> in ein <code>int</code> umwandeln. N\u00e4mlich mithilfe der <code>parseInt(String)</code>-Methode der Klasse <code>Integer</code>. Was aber passiert, wenn der <code>String</code> gar keiner Zahl entspricht? Dann wird eine Exception geworfen und das Programm sofort beendet. Wir k\u00f6nnen aber gar nichts daf\u00fcr, dass die Nutzerin keine Zahl eingegeben hat. Unser Programm ist eigentlich korrekt. Wie k\u00f6nnen wir den Programmabsturz verhindern? Wie k\u00f6nnen wir die Nutzerin solange bitten, eine Zahl einzugeben, bis sie wirklich eine Zahl eingibt?</p>"}]}